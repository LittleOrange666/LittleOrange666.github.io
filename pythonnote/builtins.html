<html>

<head>
    <title>python builtins</title>
    <base target="_top">
    <link href="https://littleorange666.github.io/style/codehilite.css" rel="stylesheet">
    <link href="https://littleorange666.github.io/style/main.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-wEmeIV1mKuiNpC+IOBjI7aAzPcEZeedi5yW5f2yOq55WWLwNGmvvx4Um1vskeMj0" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-p34f1UUtsS3wqzfto5wAAmdvj+osOnFyQFpp4Ua3gs/ZVWx6oOypYoCJhGGScy+8" crossorigin="anonymous"></script>
    <script src="https://littleorange666.github.io/script/jquery.js"></script>
</head>

<body>
    <div id="top_area">
        <nav class="navbar navbar-expand-lg navbar-light bg-light">
            <div class="container-fluid">
                <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                    <li class="nav-item">
                        <a class="nav-link active" aria-current="page" href="https://littleorange666.github.io/">首頁</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link active" aria-current="page" href="#" id="previous">前一頁</a>
                    </li>
                </ul>
            </div>
        </nav>
    </div>
    <div id="indexbar" class="toc"></div>
    <div id="main_area" class="container-fluid" data-hard-breaks="true">
        <h1 id="python">Python內建物件</h1>
<h2 id="_1">類別</h2>
<h3 id="bool">bool</h3>
<p>布林值，只有<strong>True</strong>和<strong>False</strong>兩個值<br>
是<strong>int</strong>的子類別<br>
可用方法：與<strong>int</strong>相同<br>
可用<strong>bool()</strong>取得任意類型的布林值</p>
<h3 id="int">int</h3>
<p>整數，可正可負，沒有大小限制，不會失真<br>
可用<strong>int()</strong>把其他類型轉換為整數<br>
<details><summary>可用屬性與方法</p></summary>
<h4 id="_2">屬性：</h4>
<p><strong>denominator: int</strong><br>
化為分數的分母</p>
<p><strong>imag: int</strong><br>
虛部</p>
<p><strong>numerator: int</strong><br>
化為分數的分子</p>
<p><strong>real: int</strong><br>
實部</p>
<h4 id="_3">方法：</h4>
<p><strong>as_integer_ratio() -> tuple[int, int]</strong><br>
化為分數</p>
<p><strong>bit_count()->int</strong><br>
在二進位表示法下有幾個<strong>1</strong></p>
<p><strong>bit_length()->int</strong><br>
至少占用了多少個位元</p>
<p><strong>conjugate()->int</strong><br>
共軛複數</p>
<p><strong>to_bytes(length: int, byteorder: str)->bytes</strong><br>
轉換成<strong>bytes</strong><br>
byteorder表示位元組順序<br>
用"little"表示小端序、"big"表示大端序<br>
可用<strong>sys.byteorder</strong>取得系統慣用的位元組順序</p>
<h4 id="_4">類別方法：</h4>
<p><strong>from_bytes(sources: bytes, byteorder: str)->int</strong><br>
把<strong>bytes</strong>轉換為<strong>int</strong><br>
byteorder表示位元組順序<br>
用"little"表示小端序、"big"表示大端序<br>
可用<strong>sys.byteorder</strong>取得系統慣用的位元組順序<br>
</details></p>
<h3 id="float">float</h3>
<p>浮點數(實數)，可正可負，有大小限制，是雙倍精度浮點數<br>
要更高精度可以用<strong>decimal</strong>函數庫<br>
可用<strong>float()</strong>把其他類型轉換為浮點數<br>
<details><summary>可用屬性與方法</p></summary>
<h4 id="_5">屬性：</h4>
<p><strong>imag: float</strong><br>
虛部</p>
<p><strong>real: float</strong><br>
實部</p>
<h4 id="_6">方法：</h4>
<p><strong>as_integer_ratio() -> tuple[int, int]</strong><br>
化為分數(實際儲存的值)</p>
<p><strong>conjugate()->float</strong><br>
共軛複數</p>
<p><strong>hex()->str</strong><br>
產生十六進位的浮點數表示法<br>
不會失真</p>
<p><strong>is_integer()->bool</strong><br>
是否為整數</p>
<h4 id="_7">類別方法：</h4>
<p><strong>fromhex(sources: str)->float</strong><br>
由十六進位的浮點數表示法得到浮點值<br>
不會失真<br>
</details></p>
<h3 id="complex">complex</h3>
<p>虛數，可正可負，有大小限制，是雙倍精度浮點數<br>
要更高精度可以用<strong>decimal</strong>函數庫<br>
可用<strong>complex()</strong>把其他類型轉換為虛數<br>
<details><summary>可用屬性與方法+</p></summary>
<h4 id="_8">屬性：</h4>
<p><strong>imag: float</strong><br>
虛部</p>
<p><strong>real: float</strong><br>
實部</p>
<h4 id="_9">方法：</h4>
<p><strong>conjugate()->complex</strong><br>
共軛複數<br>
</details></p>
<h3 id="str">str</h3>
<p>字串，unicode字元的序列，沒有長度限制<br>
可用<strong>str()</strong>把其他類型轉換為字串<br>
<details><summary>可用屬性與方法</p></summary>
<h4 id="_10">方法：</h4>
<p><strong>isalnum()->bool</strong><br>
判斷是否所有字元都是字母或數字<br>
空字串回傳False</p>
<p><strong>isalpha()->bool</strong><br>
判斷是否所有字元都是字母<br>
空字串回傳False</p>
<p><strong>isascii()->bool</strong><br>
判斷是否所有字元都是ASCII字元<br>
空字串回傳True</p>
<p><strong>isdecimal()->bool</strong><br>
判斷是否所有字元都是數字<br>
空字串回傳False</p>
<p><strong>isdigit()->bool</strong><br>
判斷是否所有字元都是數字<br>
空字串回傳False.</p>
<p><strong>isnumeric()->bool</strong><br>
判斷是否所有字元都是數字<br>
空字串回傳False.</p>
<p><strong>isspace()->bool</strong><br>
判斷是否所有字元都是空白字元<br>
空字串回傳False</p>
<p><strong>islower()->bool</strong><br>
判斷是否所有字母都是字小寫<br>
空字串回傳False</p>
<p><strong>isupper()->bool</strong><br>
判斷是否所有字母都是字大寫<br>
空字串回傳False</p>
<p><strong>startswith(prefix: str, start: int, end: int)->bool</strong><br>
判斷[start:end]的範圍是否以<strong>prefix</strong>開頭</p>
<p><strong>endswith(suffix: str, start: int, end: int)->bool</strong><br>
判斷[start:end]的範圍是否以<strong>suffix</strong>結尾</p>
<p><strong>find(sub: str, start: int, end: int)->int</strong><br>
找[start:end]的範圍中第一個<strong>sub</strong>的索引<br>
找不到時回傳<strong>-1</strong></p>
<p><strong>index(sub: str, start: int, end: int)->int</strong><br>
找[start:end]的範圍中第一個<strong>sub</strong>的索引，<br>
找不到時拋出<strong>ValueError</strong></p>
<p><strong>rfind(sub: str, start: int, end: int)->int</strong><br>
找[start:end]的範圍中最後一個<strong>sub</strong>的索引<br>
找不到時回傳<strong>-1</strong></p>
<p><strong>rindex(sub: str, start: int, end: int)->int</strong><br>
找[start:end]的範圍中最後一個<strong>sub</strong>的索引，<br>
找不到時拋出<strong>ValueError</strong></p>
<p><strong>count(sub: str, start: int, end: int)->int</strong><br>
計算在[start:end]的範圍中有幾個<strong>sub</strong></p>
<p><strong>join(Iterable[str])->str</strong><br>
用自身把一系列字串連接起來</p>
<p><strong>split(sep: None | str = None, maxsplit: int = -1)->list[str]</strong><br>
用<strong>sep</strong>把字串分割成一個字串列表<br>
最多進行<strong>maxsplit</strong>次分割<br>
<strong>maxsplit=-1</strong>表示無上限</p>
<p><strong>rsplit(sep: None | str = None, maxsplit: int = -1)->list[str]</strong><br>
與split相似<br>
只有<strong>maxsplit</strong>有設置的時候會不太一樣</p>
<p><strong>splitlines(keepends: bool = False)->list[str]</strong><br>
逐行分割字串<br>
<strong>keepends</strong>表示是否保留換行符</p>
<p><strong>lower()->str</strong><br>
產生小寫字串</p>
<p><strong>upper()->str</strong><br>
產生大寫字串</p>
<p><strong>capitalize()->str</strong><br>
產生首字元大寫的字串</p>
<p><strong>casefold()->str</strong><br>
產生適合無大小寫比較的字符串版本。</p>
<p>使用指定的填充字符（默認為空格）完成填充。</p>
<p><strong>center()->str</strong><br>
產生一個居中的長度寬度字符串。</p>
<p><strong>encode(encoding: str,errors: str = "strict")->bytes</strong><br>
將字串編碼為bytes<br>
errors表示對錯誤的處理方式，包括<br>
"strict": 總是丟出UnicodeEncodeError<br>
"ignore": 忽略無法編碼的字元<br>
"replace": 無法編碼則換成奇怪字元</p>
<p><strong>replace(old: str,new: str, count: int = -1)->str</strong><br>
產生把<strong>old</strong>替換成<strong>new</strong>之後的字串<br>
最多進行<strong>count</strong>次替換<br>
<strong>count=-1</strong>表示無上限</p>
<p><strong>strip(chars: None | str = None)</strong><br>
產生一個把頭尾出現在chars裡的字元刪掉後的字串<br>
若不設置則刪掉空白字元</p>
<p><strong>lstrip(chars: None | str = None)</strong><br>
產生一個把開頭出現在chars裡的字元刪掉後的字串<br>
若不設置則刪掉空白字元</p>
<p><strong>rstrip(chars: None | str = None)</strong><br>
產生一個把結尾出現在chars裡的字元刪掉後的字串<br>
若不設置則刪掉空白字元</p>
<p><strong>expandtabs</strong><br>
Return a copy where all tab characters are expanded using spaces.</p>
<p>If tabsize is not given, a tab size of 8 characters is assumed.</p>
<p><strong>format</strong><br>
The substitutions are identified by braces ('{' and '}').</p>
<p>Return a formatted version of S, using substitutions from args and kwargs.</p>
<p><strong>format_map</strong><br>
S.format_map(mapping) -> str</p>
<p>Return a formatted version of S, using substitutions from mapping.<br>
The substitutions are identified by braces ('{' and '}').</p>
<p><strong>isidentifier</strong><br>
Return True if the string is a valid Python identifier, False otherwise.</p>
<p>Call keyword.iskeyword(s) to test whether string s is a reserved identifier,<br>
such as "def" or "class".</p>
<p>A string is lowercase if all cased characters in the string are lowercase and<br>
there is at least one cased character in the string.</p>
<p><strong>isprintable</strong><br>
Return True if the string is printable, False otherwise.</p>
<p>A string is printable if all of its characters are considered printable in<br>
repr() or if it is empty.</p>
<p><strong>istitle</strong><br>
Return True if the string is a title-cased string, False otherwise.</p>
<p>In a title-cased string, upper- and title-case characters may only<br>
follow uncased characters and lowercase characters only cased ones.</p>
<p><strong>ljust</strong><br>
Return a left-justified string of length width.</p>
<p>Padding is done using the specified fill character (default is a space).</p>
<p><strong>partition</strong><br>
Partition the string into three parts using the given separator.</p>
<p>This will search for the separator in the string.  If the separator is found,<br>
returns a 3-tuple containing the part before the separator, the separator<br>
itself, and the part after it.</p>
<p>If the separator is not found, returns a 3-tuple containing the original string<br>
and two empty strings.</p>
<p><strong>removeprefix</strong><br>
Return a str with the given prefix string removed if present.</p>
<p>If the string starts with the prefix string, return string[len(prefix):].<br>
Otherwise, return a copy of the original string.</p>
<p><strong>removesuffix</strong><br>
Return a str with the given suffix string removed if present.</p>
<p>If the string ends with the suffix string and that suffix is not empty,<br>
return string[:-len(suffix)]. Otherwise, return a copy of the original<br>
string.</p>
<p><strong>rjust</strong><br>
Return a right-justified string of length width.</p>
<p>Padding is done using the specified fill character (default is a space).</p>
<p><strong>rpartition</strong><br>
Partition the string into three parts using the given separator.</p>
<p>This will search for the separator in the string, starting at the end. If<br>
the separator is found, returns a 3-tuple containing the part before the<br>
separator, the separator itself, and the part after it.</p>
<p>If the separator is not found, returns a 3-tuple containing two empty strings<br>
and the original string.</p>
<p><strong>swapcase</strong><br>
Convert uppercase characters to lowercase and lowercase characters to uppercase.</p>
<p><strong>title</strong><br>
Return a version of the string where each word is titlecased.</p>
<p>More specifically, words start with uppercased characters and all remaining<br>
cased characters have lower case.</p>
<p><strong>translate</strong><br>
Replace each character in the string using the given translation table.</p>
<p>table<br>
    Translation table, which must be a mapping of Unicode ordinals to<br>
    Unicode ordinals, strings, or None.</p>
<p>The table must implement lookup/indexing via <strong>getitem</strong>, for instance a<br>
dictionary or list.  If this operation raises LookupError, the character is<br>
left untouched.  Characters mapped to None are deleted.</p>
<p><strong>zfill</strong><br>
Pad a numeric string with zeros on the left, to fill a field of the given width.</p>
<p>The string is never truncated.</p>
<h4 id="_11">類別方法：</h4>
<p><strong>maketrans</strong><br>
Return a translation table usable for str.translate().</p>
<p>If there is only one argument, it must be a dictionary mapping Unicode<br>
ordinals (integers) or characters to Unicode ordinals, strings or None.<br>
Character keys will be then converted to ordinals.<br>
If there are two arguments, they must be strings of equal length, and<br>
in the resulting dictionary, each character in x will be mapped to the<br>
character at the same position in y. If there is a third argument, it<br>
must be a string, whose characters will be mapped to None in the result.</p>
<p></details></p>
<h3 id="tuple">tuple</h3>
<p>元組，並列且有序的一組任意長度的資料值<br>
長度不可改變，元素不可寫入<br>
<details><summary>可用屬性與方法</p></summary>
<h4 id="_12">方法：</h4>
<p><strong>count(target: Any)->int</strong><br>
計算<strong>target</strong>出現了幾次</p>
<p><strong>index(target: Any)->int</strong><br>
找出<strong>target</strong>第一次出現的索引<br>
找不到時丟出ValueError<br>
</details></p>
<h3 id="list">list</h3>
<p>列表，並列且有序的一組任意長度的資料值<br>
可插入/刪除資料<br>
<details><summary>可用屬性與方法</p></summary>
<h4 id="_13">方法：</h4>
<p><strong>append(value: Any)->None</strong><br>
在結尾加上一項</p>
<p><strong>clear()->None</strong><br>
清空列表</p>
<p><strong>copy()->list[Any]</strong><br>
淺拷貝</p>
<p><strong>count(target: Any)->int</strong><br>
計算<strong>target</strong>出現了幾次</p>
<p><strong>extend(it: Iterable[Any])</strong><br>
把it裡的所有值接在列表後方</p>
<p><strong>index(target: Any)->int</strong><br>
找出<strong>target</strong>第一次出現的索引<br>
找不到時丟出ValueError</p>
<p><strong>insert</strong><br>
Insert object before index.</p>
<p><strong>pop(index: int = -1)->Any</strong><br>
把指定的索引刪除並回傳該值<br>
若索引不存在則丟出<strong>IndexError</strong></p>
<p><strong>remove(target: Any)->None</strong><br>
刪除第一個在列表中出現的<strong>value</strong><br>
若該值不存在則丟出<strong>ValueError</strong></p>
<p><strong>reverse()->None</strong><br>
原地反轉列表</p>
<p><strong>sort(*, key: Callable[[Any],Any] = None, reverse: bool = False)</strong><br>
以升序在原地排列列表，是穩定排列<br>
若有定義<strong>key</strong>，則會把所有值都丟到<strong>key</strong>中之後再排列<br>
<strong>reverse=True</strong>可改為升序<br>
</details></p>
<h3 id="set">set</h3>
<p>集合，無序不重複的一組任意長度的資料值<br>
並能夠在常數時間裡檢查一元素是否在集合中<br>
類似數學上的集合<br>
類似C++的unordered_set<br>
不能存可變的值，如：list、set、dict<br>
要存其他set必須轉換成frozenset<br>
<details><summary>可用屬性與方法</p></summary>
<h4 id="_14">方法：</h4>
<p><strong>add(value: Any)->None</strong><br>
在集合中加入一個值</p>
<p><strong>clear()->None</strong><br>
清空集合</p>
<p><strong>discard(value: Any)->None</strong><br>
在集合中刪除一個值<br>
該值不存在時無效果</p>
<p><strong>remove(value: Any)->None</strong><br>
在集合中刪除一個值<br>
該值不存在時丟出KeyError</p>
<p><strong>pop()->Any</strong><br>
在集合中任意<strong>不是隨機的</strong>刪除一個值並回傳<br>
集合為空時丟出KeyError</p>
<p><strong>isdisjoint(other: Iterable)->bool</strong><br>
是否與<strong>other</strong>互斥</p>
<p><strong>issubset(other: Iterable)->bool</strong><br>
是否是<strong>other</strong>的子集</p>
<p><strong>issuperset(other: Iterable)->bool</strong><br>
是否是<strong>other</strong>的超集</p>
<p><strong>copy()->frozenset</strong><br>
淺拷貝</p>
<p><strong>difference(*others: Iterable)->set</strong><br>
回傳差集，可以用逗號區隔多個集合</p>
<p><strong>intersection(*others: Iterable)->set</strong><br>
回傳交集，可以用逗號區隔多個集合</p>
<p><strong>symmetric_difference(other: Iterable)->set</strong><br>
回傳對稱差</p>
<p><strong>difference_update(*others: Iterable)->None</strong><br>
原地求差集，可以用逗號區隔多個集合</p>
<p><strong>intersection_update(*others: Iterable)->None</strong><br>
原地求交集，可以用逗號區隔多個集合</p>
<p><strong>symmetric_difference_update(other: Iterable)->None</strong><br>
原地求對稱差</p>
<p><strong>union(*others: Iterable)->set</strong><br>
求聯集，可以用逗號區隔多個集合</p>
<p><strong>update(*others: Iterable)->None</strong><br>
原地求聯集<br>
</details></p>
<h3 id="frozenset">frozenset</h3>
<p>與<strong>set</strong>相同，只是不能修改內部的值<br>
<details><summary>可用屬性與方法</p></summary>
<h4 id="_15">方法：</h4>
<p><strong>isdisjoint(other: Iterable)->bool</strong><br>
是否與<strong>other</strong>互斥</p>
<p><strong>issubset(other: Iterable)->bool</strong><br>
是否是<strong>other</strong>的子集</p>
<p><strong>issuperset(other: Iterable)->bool</strong><br>
是否是<strong>other</strong>的超集</p>
<p><strong>copy()->frozenset</strong><br>
淺拷貝</p>
<p><strong>difference(*others: Iterable)->frozenset</strong><br>
求差集，可以用逗號區隔多個集合</p>
<p><strong>intersection(*others: Iterable)->frozenset</strong><br>
求交集，可以用逗號區隔多個集合</p>
<p><strong>symmetric_difference(other: Iterable)->frozenset</strong><br>
求對稱差</p>
<p><strong>union(*others: Iterable)->frozenset</strong><br>
求聯集，可以用逗號區隔多個集合<br>
</details></p>
<h3 id="dict">dict</h3>
<p>字典，鍵-值對的資料結構<br>
鍵保證唯一，值不保證唯一<br>
在較新的python版本(3.7+)中鍵會按照加入的順序排列<br>
<details><summary>可用屬性與方法</p></summary>
<h4 id="_16">方法：</h4>
<p><strong>clear()->None</strong><br>
清空字典</p>
<p><strong>copy()->dict</strong><br>
淺拷貝</p>
<p><strong>get(key: Any, default: Any = None)->Any</strong><br>
取得<strong>key</strong>代表的值，若不存在則回傳<strong>default</strong></p>
<p><strong>keys()->dict_keys</strong><br>
獲取所有鍵值的鏡像<br>
dict_keys與原字典綁定<br>
且是可迭代物件</p>
<p><strong>values()->dict_values</strong><br>
獲取所有值的鏡像<br>
dict_values與原字典綁定<br>
且是可迭代物件</p>
<p><strong>items()->dict_items</strong><br>
獲取所有鍵-值對的鏡像<br>
dict_items與原字典綁定<br>
且是可迭代物件，每一項都是<strong>(key,value)</strong></p>
<p><strong>pop(key: Any, default: Any)</strong><br>
取得並刪除<strong>key</strong>代表的值，若不存在則回傳<strong>default</strong><br>
若<strong>key</strong>不存在且<strong>default</strong>未設置則丟出KeyError</p>
<p><strong>popitem()->tuple[Any, Any]</strong><br>
在字典中刪除第一個鍵-值對並回傳<br>
自店為空時丟出KeyError</p>
<p><strong>setdefault(key: Any, value: Any)->Any</strong><br>
如果<strong>key</strong>不存在則把<strong>key</strong>的值設為<strong>value</strong><br>
回傳<strong>key</strong>最後的值</p>
<p><strong>update(other: Iterable)->None</strong><br>
試圖用<strong>other</strong>來更新自身<br>
<strong>other</strong>應該是一系列的鍵-值對<br>
或可以用<strong>keys()</strong>獲取所有鍵值的類dict結構</p>
<h4 id="_17">類別方法：</h4>
<p><strong>fromkeys(keys: Iterable, value: Any = None)</strong><br>
以<strong>keys</strong>的鍵值建立一個字典<br>
並把值都設為<strong>value</strong><br>
</details></p>
<h3 id="bytearray">bytearray</h3>
<p>位元陣列，專門儲存位元序列，可寫入<br>
<details><summary>可用屬性與方法</p></summary>
<h4 id="_18">方法：</h4>
<p><strong>append</strong><br>
Append a single item to the end of the bytearray.</p>
<p>item<br>
    The item to be appended.</p>
<p><strong>capitalize</strong><br>
B.capitalize() -> copy of B</p>
<p>Return a copy of B with only its first character capitalized (ASCII)<br>
and the rest lower-cased.</p>
<p><strong>center</strong><br>
Return a centered string of length width.</p>
<p>Padding is done using the specified fill character.</p>
<p><strong>clear</strong><br>
Remove all items from the bytearray.</p>
<p><strong>copy</strong><br>
Return a copy of B.</p>
<p><strong>count</strong><br>
B.count(sub[, start[, end]]) -> int</p>
<p>Return the number of non-overlapping occurrences of subsection sub in<br>
bytes B[start:end].  Optional arguments start and end are interpreted<br>
as in slice notation.</p>
<p><strong>decode</strong><br>
Decode the bytearray using the codec registered for encoding.</p>
<p>encoding<br>
    The encoding with which to decode the bytearray.<br>
  errors<br>
    The error handling scheme to use for the handling of decoding errors.<br>
    The default is 'strict' meaning that decoding errors raise a<br>
    UnicodeDecodeError. Other possible values are 'ignore' and 'replace'<br>
    as well as any other name registered with codecs.register_error that<br>
    can handle UnicodeDecodeErrors.</p>
<p><strong>endswith</strong><br>
B.endswith(suffix[, start[, end]]) -> bool</p>
<p>Return True if B ends with the specified suffix, False otherwise.<br>
With optional start, test B beginning at that position.<br>
With optional end, stop comparing B at that position.<br>
suffix can also be a tuple of bytes to try.</p>
<p><strong>expandtabs</strong><br>
Return a copy where all tab characters are expanded using spaces.</p>
<p>If tabsize is not given, a tab size of 8 characters is assumed.</p>
<p><strong>extend</strong><br>
Append all the items from the iterator or sequence to the end of the bytearray.</p>
<p>iterable_of_ints<br>
    The iterable of items to append.</p>
<p><strong>find</strong><br>
B.find(sub[, start[, end]]) -> int</p>
<p>Return the lowest index in B where subsection sub is found,<br>
such that sub is contained within B[start,end].  Optional<br>
arguments start and end are interpreted as in slice notation.</p>
<p>Return -1 on failure.</p>
<p><strong>hex</strong><br>
Create a string of hexadecimal numbers from a bytearray object.</p>
<p>sep<br>
    An optional single character or byte to separate hex bytes.<br>
  bytes_per_sep<br>
    How many bytes between separators.  Positive values count from the<br>
    right, negative values count from the left.</p>
<p>Example:</p>
<blockquote>
<blockquote>
<blockquote>
<p>value = bytearray([0xb9, 0x01, 0xef])<br>
value.hex()<br>
'b901ef'<br>
value.hex(':')<br>
'b9:01:ef'<br>
value.hex(':', 2)<br>
'b9:01ef'<br>
value.hex(':', -2)<br>
'b901:ef'</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>index</strong><br>
B.index(sub[, start[, end]]) -> int</p>
<p>Return the lowest index in B where subsection sub is found,<br>
such that sub is contained within B[start,end].  Optional<br>
arguments start and end are interpreted as in slice notation.</p>
<p>Raises ValueError when the subsection is not found.</p>
<p><strong>insert</strong><br>
Insert a single item into the bytearray before the given index.</p>
<p>index<br>
    The index where the value is to be inserted.<br>
  item<br>
    The item to be inserted.</p>
<p><strong>isalnum</strong><br>
B.isalnum() -> bool</p>
<p>Return True if all characters in B are alphanumeric<br>
and there is at least one character in B, False otherwise.</p>
<p><strong>isalpha</strong><br>
B.isalpha() -> bool</p>
<p>Return True if all characters in B are alphabetic<br>
and there is at least one character in B, False otherwise.</p>
<p><strong>isascii</strong><br>
B.isascii() -> bool</p>
<p>Return True if B is empty or all characters in B are ASCII,<br>
False otherwise.</p>
<p><strong>isdigit</strong><br>
B.isdigit() -> bool</p>
<p>Return True if all characters in B are digits<br>
and there is at least one character in B, False otherwise.</p>
<p><strong>islower</strong><br>
B.islower() -> bool</p>
<p>Return True if all cased characters in B are lowercase and there is<br>
at least one cased character in B, False otherwise.</p>
<p><strong>isspace</strong><br>
B.isspace() -> bool</p>
<p>Return True if all characters in B are whitespace<br>
and there is at least one character in B, False otherwise.</p>
<p><strong>istitle</strong><br>
B.istitle() -> bool</p>
<p>Return True if B is a titlecased string and there is at least one<br>
character in B, i.e. uppercase characters may only follow uncased<br>
characters and lowercase characters only cased ones. Return False<br>
otherwise.</p>
<p><strong>isupper</strong><br>
B.isupper() -> bool</p>
<p>Return True if all cased characters in B are uppercase and there is<br>
at least one cased character in B, False otherwise.</p>
<p><strong>join</strong><br>
Concatenate any number of bytes/bytearray objects.</p>
<p>The bytearray whose method is called is inserted in between each pair.</p>
<p>The result is returned as a new bytearray object.</p>
<p><strong>ljust</strong><br>
Return a left-justified string of length width.</p>
<p>Padding is done using the specified fill character.</p>
<p><strong>lower</strong><br>
B.lower() -> copy of B</p>
<p>Return a copy of B with all ASCII characters converted to lowercase.</p>
<p><strong>lstrip</strong><br>
Strip leading bytes contained in the argument.</p>
<p>If the argument is omitted or None, strip leading ASCII whitespace.</p>
<p><strong>partition</strong><br>
Partition the bytearray into three parts using the given separator.</p>
<p>This will search for the separator sep in the bytearray. If the separator is<br>
found, returns a 3-tuple containing the part before the separator, the<br>
separator itself, and the part after it as new bytearray objects.</p>
<p>If the separator is not found, returns a 3-tuple containing the copy of the<br>
original bytearray object and two empty bytearray objects.</p>
<p><strong>pop</strong><br>
Remove and return a single item from B.</p>
<p>index<br>
    The index from where to remove the item.<br>
    -1 (the default value) means remove the last item.</p>
<p>If no index argument is given, will pop the last item.</p>
<p><strong>remove</strong><br>
Remove the first occurrence of a value in the bytearray.</p>
<p>value<br>
    The value to remove.</p>
<p><strong>removeprefix</strong><br>
Return a bytearray with the given prefix string removed if present.</p>
<p>If the bytearray starts with the prefix string, return<br>
bytearray[len(prefix):].  Otherwise, return a copy of the original<br>
bytearray.</p>
<p><strong>removesuffix</strong><br>
Return a bytearray with the given suffix string removed if present.</p>
<p>If the bytearray ends with the suffix string and that suffix is not<br>
empty, return bytearray[:-len(suffix)].  Otherwise, return a copy of<br>
the original bytearray.</p>
<p><strong>replace</strong><br>
Return a copy with all occurrences of substring old replaced by new.</p>
<p>count<br>
    Maximum number of occurrences to replace.<br>
    -1 (the default value) means replace all occurrences.</p>
<p>If the optional argument count is given, only the first count occurrences are<br>
replaced.</p>
<p><strong>reverse</strong><br>
Reverse the order of the values in B in place.</p>
<p><strong>rfind</strong><br>
B.rfind(sub[, start[, end]]) -> int</p>
<p>Return the highest index in B where subsection sub is found,<br>
such that sub is contained within B[start,end].  Optional<br>
arguments start and end are interpreted as in slice notation.</p>
<p>Return -1 on failure.</p>
<p><strong>rindex</strong><br>
B.rindex(sub[, start[, end]]) -> int</p>
<p>Return the highest index in B where subsection sub is found,<br>
such that sub is contained within B[start,end].  Optional<br>
arguments start and end are interpreted as in slice notation.</p>
<p>Raise ValueError when the subsection is not found.</p>
<p><strong>rjust</strong><br>
Return a right-justified string of length width.</p>
<p>Padding is done using the specified fill character.</p>
<p><strong>rpartition</strong><br>
Partition the bytearray into three parts using the given separator.</p>
<p>This will search for the separator sep in the bytearray, starting at the end.<br>
If the separator is found, returns a 3-tuple containing the part before the<br>
separator, the separator itself, and the part after it as new bytearray<br>
objects.</p>
<p>If the separator is not found, returns a 3-tuple containing two empty bytearray<br>
objects and the copy of the original bytearray object.</p>
<p><strong>rsplit</strong><br>
Return a list of the sections in the bytearray, using sep as the delimiter.</p>
<p>sep<br>
    The delimiter according which to split the bytearray.<br>
    None (the default value) means split on ASCII whitespace characters<br>
    (space, tab, return, newline, formfeed, vertical tab).<br>
  maxsplit<br>
    Maximum number of splits to do.<br>
    -1 (the default value) means no limit.</p>
<p>Splitting is done starting at the end of the bytearray and working to the front.</p>
<p><strong>rstrip</strong><br>
Strip trailing bytes contained in the argument.</p>
<p>If the argument is omitted or None, strip trailing ASCII whitespace.</p>
<p><strong>split</strong><br>
Return a list of the sections in the bytearray, using sep as the delimiter.</p>
<p>sep<br>
    The delimiter according which to split the bytearray.<br>
    None (the default value) means split on ASCII whitespace characters<br>
    (space, tab, return, newline, formfeed, vertical tab).<br>
  maxsplit<br>
    Maximum number of splits to do.<br>
    -1 (the default value) means no limit.</p>
<p><strong>splitlines</strong><br>
Return a list of the lines in the bytearray, breaking at line boundaries.</p>
<p>Line breaks are not included in the resulting list unless keepends is given and<br>
true.</p>
<p><strong>startswith</strong><br>
B.startswith(prefix[, start[, end]]) -> bool</p>
<p>Return True if B starts with the specified prefix, False otherwise.<br>
With optional start, test B beginning at that position.<br>
With optional end, stop comparing B at that position.<br>
prefix can also be a tuple of bytes to try.</p>
<p><strong>strip</strong><br>
Strip leading and trailing bytes contained in the argument.</p>
<p>If the argument is omitted or None, strip leading and trailing ASCII whitespace.</p>
<p><strong>swapcase</strong><br>
B.swapcase() -> copy of B</p>
<p>Return a copy of B with uppercase ASCII characters converted<br>
to lowercase ASCII and vice versa.</p>
<p><strong>title</strong><br>
B.title() -> copy of B</p>
<p>Return a titlecased version of B, i.e. ASCII words start with uppercase<br>
characters, all remaining cased characters have lowercase.</p>
<p><strong>translate</strong><br>
Return a copy with each character mapped by the given translation table.</p>
<p>table<br>
    Translation table, which must be a bytes object of length 256.</p>
<p>All characters occurring in the optional argument delete are removed.<br>
The remaining characters are mapped through the given translation table.</p>
<p><strong>upper</strong><br>
B.upper() -> copy of B</p>
<p>Return a copy of B with all ASCII characters converted to uppercase.</p>
<p><strong>zfill</strong><br>
Pad a numeric string with zeros on the left, to fill a field of the given width.</p>
<p>The original string is never truncated.</p>
<h4 id="_19">類別方法：</h4>
<p><strong>fromhex</strong><br>
Create a bytearray object from a string of hexadecimal numbers.</p>
<p>Spaces between two numbers are accepted.<br>
Example: bytearray.fromhex('B9 01EF') -> bytearray(b'\xb9\x01\xef')</p>
<p><strong>maketrans</strong><br>
Return a translation table useable for the bytes or bytearray translate method.</p>
<p>The returned table will be one where each byte in frm is mapped to the byte at<br>
the same position in to.</p>
<p>The bytes objects frm and to must be of the same length.</p>
<p></details></p>
<h3 id="bytes">bytes</h3>
<h3 id="enumerate">enumerate</h3>
<h3 id="filter">filter</h3>
<h3 id="map">map</h3>
<h3 id="zip">zip</h3>
<h3 id="memoryview">memoryview</h3>
<h3 id="range">range</h3>
<h3 id="slice">slice</h3>
<h3 id="reversed">reversed</h3>
<h3 id="classmethod">classmethod</h3>
<h3 id="staticmethod">staticmethod</h3>
<h3 id="property">property</h3>
<h3 id="super">super</h3>
<h3 id="type">type</h3>
<h3 id="object">object</h3>
<h2 id="_20">函數</h2>
<h3 id="abs">abs</h3>
<h3 id="pow">pow</h3>
<h3 id="round">round</h3>
<h3 id="divmod">divmod</h3>
<h3 id="max">max</h3>
<h3 id="min">min</h3>
<h3 id="sum">sum</h3>
<h3 id="sorted">sorted</h3>
<h3 id="print">print</h3>
<h3 id="input">input</h3>
<h3 id="open">open</h3>
<h3 id="all">all</h3>
<h3 id="any">any</h3>
<h3 id="hex">hex</h3>
<h3 id="oct">oct</h3>
<h3 id="bin">bin</h3>
<h3 id="ascii">ascii</h3>
<h3 id="chr">chr</h3>
<h3 id="ord">ord</h3>
<h3 id="repr">repr</h3>
<h3 id="format">format</h3>
<h3 id="id">id</h3>
<h3 id="len">len</h3>
<h3 id="hash">hash</h3>
<h3 id="iter">iter</h3>
<h3 id="next">next</h3>
<h3 id="aiter">aiter</h3>
<h3 id="anext">anext</h3>
<h3 id="compile">compile</h3>
<h3 id="breakpoint">breakpoint</h3>
<h3 id="dir">dir</h3>
<h3 id="eval">eval</h3>
<h3 id="exec">exec</h3>
<h3 id="getattr">getattr</h3>
<h3 id="setattr">setattr</h3>
<h3 id="delattr">delattr</h3>
<h3 id="hasattr">hasattr</h3>
<h3 id="isinstance">isinstance</h3>
<h3 id="issubclass">issubclass</h3>
<h3 id="callable">callable</h3>
<h3 id="locals">locals</h3>
<h3 id="globals">globals</h3>
<h3 id="quit">quit</h3>
<h3 id="exit">exit</h3>
<h3 id="vars">vars</h3>
<h3 id="copyright">copyright</h3>
<h3 id="credits">credits</h3>
<h3 id="license">license</h3>
<h3 id="help">help</h3>
<h2 id="_21">特殊</h2>
<h3 id="false">False</h3>
<h3 id="true">True</h3>
<h3 id="ellipsis">Ellipsis</h3>
<h3 id="none">None</h3>
<h3 id="notimplemented">NotImplemented</h3>
<h2 id="_22">例外</h2>
<h3 id="arithmeticerror">ArithmeticError</h3>
<h3 id="assertionerror">AssertionError</h3>
<h3 id="attributeerror">AttributeError</h3>
<h3 id="baseexception">BaseException</h3>
<h3 id="blockingioerror">BlockingIOError</h3>
<h3 id="brokenpipeerror">BrokenPipeError</h3>
<h3 id="buffererror">BufferError</h3>
<h3 id="byteswarning">BytesWarning</h3>
<h3 id="childprocesserror">ChildProcessError</h3>
<h3 id="connectionabortederror">ConnectionAbortedError</h3>
<h3 id="connectionerror">ConnectionError</h3>
<h3 id="connectionrefusederror">ConnectionRefusedError</h3>
<h3 id="connectionreseterror">ConnectionResetError</h3>
<h3 id="deprecationwarning">DeprecationWarning</h3>
<h3 id="eoferror">EOFError</h3>
<h3 id="encodingwarning">EncodingWarning</h3>
<h3 id="environmenterror">EnvironmentError</h3>
<h3 id="exception">Exception</h3>
<h3 id="fileexistserror">FileExistsError</h3>
<h3 id="filenotfounderror">FileNotFoundError</h3>
<h3 id="floatingpointerror">FloatingPointError</h3>
<h3 id="futurewarning">FutureWarning</h3>
<h3 id="generatorexit">GeneratorExit</h3>
<h3 id="ioerror">IOError</h3>
<h3 id="importerror">ImportError</h3>
<h3 id="importwarning">ImportWarning</h3>
<h3 id="indentationerror">IndentationError</h3>
<h3 id="indexerror">IndexError</h3>
<h3 id="interruptederror">InterruptedError</h3>
<h3 id="isadirectoryerror">IsADirectoryError</h3>
<h3 id="keyerror">KeyError</h3>
<h3 id="keyboardinterrupt">KeyboardInterrupt</h3>
<h3 id="lookuperror">LookupError</h3>
<h3 id="memoryerror">MemoryError</h3>
<h3 id="modulenotfounderror">ModuleNotFoundError</h3>
<h3 id="nameerror">NameError</h3>
<h3 id="notadirectoryerror">NotADirectoryError</h3>
<h3 id="notimplementederror">NotImplementedError</h3>
<h3 id="oserror">OSError</h3>
<h3 id="overflowerror">OverflowError</h3>
<h3 id="pendingdeprecationwarning">PendingDeprecationWarning</h3>
<h3 id="permissionerror">PermissionError</h3>
<h3 id="processlookuperror">ProcessLookupError</h3>
<h3 id="recursionerror">RecursionError</h3>
<h3 id="referenceerror">ReferenceError</h3>
<h3 id="resourcewarning">ResourceWarning</h3>
<h3 id="runtimeerror">RuntimeError</h3>
<h3 id="runtimewarning">RuntimeWarning</h3>
<h3 id="stopasynciteration">StopAsyncIteration</h3>
<h3 id="stopiteration">StopIteration</h3>
<h3 id="syntaxerror">SyntaxError</h3>
<h3 id="syntaxwarning">SyntaxWarning</h3>
<h3 id="systemerror">SystemError</h3>
<h3 id="systemexit">SystemExit</h3>
<h3 id="taberror">TabError</h3>
<h3 id="timeouterror">TimeoutError</h3>
<h3 id="typeerror">TypeError</h3>
<h3 id="unboundlocalerror">UnboundLocalError</h3>
<h3 id="unicodedecodeerror">UnicodeDecodeError</h3>
<h3 id="unicodeencodeerror">UnicodeEncodeError</h3>
<h3 id="unicodeerror">UnicodeError</h3>
<h3 id="unicodetranslateerror">UnicodeTranslateError</h3>
<h3 id="unicodewarning">UnicodeWarning</h3>
<h3 id="userwarning">UserWarning</h3>
<h3 id="valueerror">ValueError</h3>
<h3 id="warning">Warning</h3>
<h3 id="windowserror">WindowsError</h3>
<h3 id="zerodivisionerror">ZeroDivisionError</h3>
    </div>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            config: ["MMLorHTML.js"],
            jax: ["input/TeX", "output/HTML-CSS", "output/NativeMML"],
            extensions: ["MathMenu.js", "MathZoom.js"]
        });
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
    <script src="https://littleorange666.github.io/script/main.js"></script>
</body>

</html>