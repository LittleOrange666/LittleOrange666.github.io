[{"title":"Hello World","date":"2022-04-30T11:59:41.804Z","url":"/2022/04/30/hello-world/","categories":[[" ",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"},{"title":"Python函數","date":"2022-04-30T01:48:20.687Z","url":"/2022/04/30/function/","tags":[["programming,Python","/tags/programming-Python/"]],"categories":[[" ",""]],"content":"函數何謂函數匿名函數生成器修飾器協程"},{"title":"Python變數與型別","date":"2022-04-30T01:48:12.110Z","url":"/2022/04/30/variable/","tags":[["programming,Python","/tags/programming-Python/"]],"categories":[[" ",""]],"content":"變數與型別作用域所有的默認型別型別提示"},{"title":"Python自訂型別","date":"2022-04-30T01:48:02.806Z","url":"/2022/04/30/class/","tags":[["programming,Python","/tags/programming-Python/"]],"categories":[[" ",""]],"content":"自訂型別class繼承屬性自定義運算子"},{"title":"python builtins","date":"2022-04-30T01:47:49.964Z","url":"/2022/04/30/builtins/","tags":[["programming,Python","/tags/programming-Python/"]],"categories":[[" ",""]],"content":"談談builtins未完成，先隨便放點東西 常數:EllipsisFalse:bool(x) -&gt; boolReturns True when the argument x is true, False otherwise.The builtins True and False are the only two instances of the class bool.The class bool is a subclass of the class int, and cannot be subclassed. NoneNotImplementedTrue:bool(x) -&gt; boolReturns True when the argument x is true, False otherwise.The builtins True and False are the only two instances of the class bool.The class bool is a subclass of the class int, and cannot be subclassed. 函數:abs(x):Return the absolute value of the argument. aiter(async_iterable):Return an AsyncIterator for an AsyncIterable object. all(iterable):Return True if bool(x) is True for all values x in the iterable.If the iterable is empty, return True. anext():Return the next item from the async iterator. any(iterable):Return True if bool(x) is True for any x in the iterable.If the iterable is empty, return False. ascii(obj):Return an ASCII-only representation of an object.As repr(), return a string containing a printable representation of anobject, but escape the non-ASCII characters in the string returned byrepr() using \\x, \\u or \\U escapes. This generates a string similarto that returned by repr() in Python 2. bin(number):Return the binary representation of an integer. &gt;&gt;&gt; bin(2796202) ‘0b1010101010101010101010’ breakpoint():breakpoint(*args, **kws)Call sys.breakpointhook(*args, **kws). sys.breakpointhook() must acceptwhatever arguments are passed.By default, this drops you into the pdb debugger. callable(obj):Return whether the object is callable (i.e., some kind of function).Note that classes are callable, as are instances of classes with acall() method. chr(i):Return a Unicode string of one character with ordinal i; 0 &lt;&#x3D; i &lt;&#x3D; 0x10ffff. compile(source, filename, mode, flags&#x3D;0, dont_inherit&#x3D;False, optimize&#x3D;-1, _feature_version&#x3D;-1):Compile source into a code object that can be executed by exec() or eval().The source code may represent a Python module, statement or expression.The filename will be used for run-time error messages.The mode must be ‘exec’ to compile a module, ‘single’ to compile asingle (interactive) statement, or ‘eval’ to compile an expression.The flags argument, if present, controls which future statements influencethe compilation of the code.The dont_inherit argument, if true, stops the compilation inheritingthe effects of any future statements in effect in the code callingcompile; if absent or false these statements do influence the compilation,in addition to any features explicitly specified. copyright():interactive prompt objects for printing the license text, a list of contributors and the copyright notice. credits():interactive prompt objects for printing the license text, a list of contributors and the copyright notice. delattr(obj, name):Deletes the named attribute from the given object.delattr(x, ‘y’) is equivalent to ‘’del x.y’’ dir():dir([object]) -&gt; list of stringsIf called without an argument, return the names in the current scope.Else, return an alphabetized list of names comprising (some of) the attributesof the given object, and of attributes reachable from it.If the object supplies a method named dir, it will be used; otherwisethe default dir() logic is used and returns: for a module object: the module’s attributes. for a class object: its attributes, and recursively the attributes of its bases. for any other object: its attributes, its class’s attributes, and recursively the attributes of its class’s base classes. divmod(x, y):Return the tuple (x&#x2F;&#x2F;y, x%y). Invariant: div*y + mod &#x3D;&#x3D; x. eval(source, globals&#x3D;None, locals&#x3D;None):Evaluate the given source in the context of globals and locals.The source may be a string representing a Python expressionor a code object as returned by compile().The globals must be a dictionary and locals can be any mapping,defaulting to the current globals and locals.If only globals is given, locals defaults to it. exec(source, globals&#x3D;None, locals&#x3D;None):Execute the given source in the context of globals and locals.The source may be a string representing one or more Python statementsor a code object as returned by compile().The globals must be a dictionary and locals can be any mapping,defaulting to the current globals and locals.If only globals is given, locals defaults to it. exit(code&#x3D;None):format(value, format_spec&#x3D;’’):Return value.format(format_spec)format_spec defaults to the empty string.See the Format Specification Mini-Language section of help(‘FORMATTING’) fordetails. getattr():getattr(object, name[, default]) -&gt; valueGet a named attribute from an object; getattr(x, ‘y’) is equivalent to x.y.When a default argument is given, it is returned when the attribute doesn’texist; without it, an exception is raised in that case. globals():Return the dictionary containing the current scope’s global variables.NOTE: Updates to this dictionary *will* affect name lookups in the currentglobal scope and vice-versa. hasattr(obj, name):Return whether the object has an attribute with the given name.This is done by calling getattr(obj, name) and catching AttributeError. hash(obj):Return the hash value for the given object.Two objects that compare equal must also have the same hash value, but thereverse is not necessarily true. help(*args, **kwds):Define the builtin ‘help’. This is a wrapper around pydoc.help that provides a helpful message when ‘help’ is typed at the Python interactive prompt. Calling help() at the Python prompt starts an interactive help session. Calling help(thing) prints help for the python object ‘thing’. hex(number):Return the hexadecimal representation of an integer. &gt;&gt;&gt; hex(12648430) ‘0xc0ffee’ id(obj):Return the identity of an object.This is guaranteed to be unique among simultaneously existing objects.(CPython uses the object’s memory address.) input(prompt&#x3D;None):Read a string from standard input. The trailing newline is stripped.The prompt string, if given, is printed to standard output without atrailing newline before reading input.If the user hits EOF (*nix: Ctrl-D, Windows: Ctrl-Z+Return), raise EOFError.On *nix systems, readline is used if available. isinstance(obj, class_or_tuple):Return whether an object is an instance of a class or of a subclass thereof.A tuple, as in isinstance(x, (A, B, ...)), may be given as the target tocheck against. This is equivalent to isinstance(x, A) or isinstance(x, B) or ... etc. issubclass(cls, class_or_tuple):Return whether ‘cls’ is derived from another class or is the same class.A tuple, as in issubclass(x, (A, B, ...)), may be given as the target tocheck against. This is equivalent to issubclass(x, A) or issubclass(x, B) or .... iter():iter(iterable) -&gt; iteratoriter(callable, sentinel) -&gt; iteratorGet an iterator from an object. In the first form, the argument mustsupply its own iterator, or be a sequence.In the second form, the callable is called until it returns the sentinel. len(obj):Return the number of items in a container. license():interactive prompt objects for printing the license text, a list of contributors and the copyright notice. locals():Return a dictionary containing the current scope’s local variables.NOTE: Whether or not updates to this dictionary will affect name lookups inthe local scope and vice-versa is *implementation dependent* and notcovered by any backwards compatibility guarantees. max():max(iterable, *[, default&#x3D;obj, key&#x3D;func]) -&gt; valuemax(arg1, arg2, *args, *[, key&#x3D;func]) -&gt; valueWith a single iterable argument, return its biggest item. Thedefault keyword-only argument specifies an object to return ifthe provided iterable is empty.With two or more arguments, return the largest argument. min():min(iterable, *[, default&#x3D;obj, key&#x3D;func]) -&gt; valuemin(arg1, arg2, *args, *[, key&#x3D;func]) -&gt; valueWith a single iterable argument, return its smallest item. Thedefault keyword-only argument specifies an object to return ifthe provided iterable is empty.With two or more arguments, return the smallest argument. next():next(iterator[, default])Return the next item from the iterator. If default is given and the iteratoris exhausted, it is returned instead of raising StopIteration. oct(number):Return the octal representation of an integer. &gt;&gt;&gt; oct(342391) ‘0o1234567’ open(file, mode&#x3D;’r’, buffering&#x3D;-1, encoding&#x3D;None, errors&#x3D;None, newline&#x3D;None, closefd&#x3D;True, opener&#x3D;None):Open file and return a stream. Raise OSError upon failure.file is either a text or byte string giving the name (and the pathif the file isn’t in the current working directory) of the file tobe opened or an integer file descriptor of the file to bewrapped. (If a file descriptor is given, it is closed when thereturned I&#x2F;O object is closed, unless closefd is set to False.)mode is an optional string that specifies the mode in which the fileis opened. It defaults to ‘r’ which means open for reading in textmode. Other common values are ‘w’ for writing (truncating the file ifit already exists), ‘x’ for creating and writing to a new file, and‘a’ for appending (which on some Unix systems, means that all writesappend to the end of the file regardless of the current seek position).In text mode, if encoding is not specified the encoding used is platformdependent: locale.getpreferredencoding(False) is called to get thecurrent locale encoding. (For reading and writing raw bytes use binarymode and leave encoding unspecified.) The available modes are:&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Character Meaning ‘r’ open for reading (default)‘w’ open for writing, truncating the file first‘x’ create a new file and open it for writing‘a’ open for writing, appending to the end of the file if it exists‘b’ binary mode‘t’ text mode (default)‘+’ open a disk file for updating (reading and writing)‘U’ universal newline mode (deprecated)&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;The default mode is ‘rt’ (open for reading text). For binary randomaccess, the mode ‘w+b’ opens and truncates the file to 0 bytes, while‘r+b’ opens the file without truncation. The ‘x’ mode implies ‘w’ andraises an FileExistsError if the file already exists.Python distinguishes between files opened in binary and text modes,even when the underlying operating system doesn’t. Files opened inbinary mode (appending ‘b’ to the mode argument) return contents asbytes objects without any decoding. In text mode (the default, or when‘t’ is appended to the mode argument), the contents of the file arereturned as strings, the bytes having been first decoded using aplatform-dependent encoding or using the specified encoding if given.‘U’ mode is deprecated and will raise an exception in future versionsof Python. It has no effect in Python 3. Use newline to controluniversal newlines mode.buffering is an optional integer used to set the buffering policy.Pass 0 to switch buffering off (only allowed in binary mode), 1 to selectline buffering (only usable in text mode), and an integer &gt; 1 to indicatethe size of a fixed-size chunk buffer. When no buffering argument isgiven, the default buffering policy works as follows:* Binary files are buffered in fixed-size chunks; the size of the buffer is chosen using a heuristic trying to determine the underlying device’s “block size” and falling back on io.DEFAULT_BUFFER_SIZE. On many systems, the buffer will typically be 4096 or 8192 bytes long.* “Interactive” text files (files for which isatty() returns True) use line buffering. Other text files use the policy described above for binary files.encoding is the name of the encoding used to decode or encode thefile. This should only be used in text mode. The default encoding isplatform dependent, but any encoding supported by Python can bepassed. See the codecs module for the list of supported encodings.errors is an optional string that specifies how encoding errors are tobe handled—this argument should not be used in binary mode. Pass‘strict’ to raise a ValueError exception if there is an encoding error(the default of None has the same effect), or pass ‘ignore’ to ignoreerrors. (Note that ignoring encoding errors can lead to data loss.)See the documentation for codecs.register or run ‘help(codecs.Codec)’for a list of the permitted encoding error strings.newline controls how universal newlines works (it only applies to textmode). It can be None, ‘’, ‘\\n’, ‘\\r’, and ‘\\r\\n’. It works asfollows:* On input, if newline is None, universal newlines mode is enabled. Lines in the input can end in ‘\\n’, ‘\\r’, or ‘\\r\\n’, and these are translated into ‘\\n’ before being returned to the caller. If it is ‘’, universal newline mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.* On output, if newline is None, any ‘\\n’ characters written are translated to the system default line separator, os.linesep. If newline is ‘’ or ‘\\n’, no translation takes place. If newline is any of the other legal values, any ‘\\n’ characters written are translated to the given string.If closefd is False, the underlying file descriptor will be kept openwhen the file is closed. This does not work when a file name is givenand must be True in that case.A custom opener can be used by passing a callable as *opener*. Theunderlying file descriptor for the file object is then obtained bycalling *opener* with (*file*, *flags*). *opener* must return an openfile descriptor (passing os.open as *opener* results in functionalitysimilar to passing None).open() returns a file object whose type depends on the mode, andthrough which the standard file operations such as reading and writingare performed. When open() is used to open a file in a text mode (‘w’,‘r’, ‘wt’, ‘rt’, etc.), it returns a TextIOWrapper. When used to opena file in a binary mode, the returned class varies: in read binarymode, it returns a BufferedReader; in write binary and append binarymodes, it returns a BufferedWriter, and in read&#x2F;write mode, it returnsa BufferedRandom.It is also possible to use a string or bytearray as a file for bothreading and writing. For strings StringIO can be used like a fileopened in a text mode, and for bytes a BytesIO can be used like a fileopened in a binary mode. ord(c):Return the Unicode code point for a one-character string. pow(base, exp, mod&#x3D;None):Equivalent to base**exp with 2 arguments or base**exp % mod with 3 argumentsSome types, such as ints, are able to use a more efficient algorithm wheninvoked using the three argument form. print():print(value, …, sep&#x3D;’ ‘, end&#x3D;’\\n’, file&#x3D;sys.stdout, flush&#x3D;False)Prints the values to a stream, or to sys.stdout by default.Optional keyword arguments:file: a file-like object (stream); defaults to the current sys.stdout.sep: string inserted between values, default a space.end: string appended after the last value, default a newline.flush: whether to forcibly flush the stream. quit(code&#x3D;None):repr(obj):Return the canonical string representation of the object.For many object types, including most builtins, eval(repr(obj)) &#x3D;&#x3D; obj. round(number, ndigits&#x3D;None):Round a number to a given precision in decimal digits.The return value is an integer if ndigits is omitted or None. Otherwisethe return value has the same type as the number. ndigits may be negative. setattr(obj, name, value):Sets the named attribute on the given object to the specified value.setattr(x, ‘y’, v) is equivalent to &#96;&#96;x.y &#x3D; v’’ sorted(iterable, key&#x3D;None, reverse&#x3D;False):Return a new list containing all items from the iterable in ascending order.A custom key function can be supplied to customize the sort order, and thereverse flag can be set to request the result in descending order. sum(iterable, start&#x3D;0):Return the sum of a ‘start’ value (default: 0) plus an iterable of numbersWhen the iterable is empty, return the start value.This function is intended specifically for use with numeric values and mayreject non-numeric types. vars():vars([object]) -&gt; dictionaryWithout arguments, equivalent to locals().With an argument, equivalent to object.dict. 類別:UnicodeDecodeError:Unicode decoding error. UnicodeEncodeError:Unicode encoding error. UnicodeTranslateError:Unicode translation error. bool:bool(x) -&gt; boolReturns True when the argument x is true, False otherwise.The builtins True and False are the only two instances of the class bool.The class bool is a subclass of the class int, and cannot be subclassed. bytearray:bytearray(iterable_of_ints) -&gt; bytearraybytearray(string, encoding[, errors]) -&gt; bytearraybytearray(bytes_or_buffer) -&gt; mutable copy of bytes_or_bufferbytearray(int) -&gt; bytes array of size given by the parameter initialized with null bytesbytearray() -&gt; empty bytes arrayConstruct a mutable bytearray object from: an iterable yielding integers in range(256) a text string encoded using the specified encoding a bytes or a buffer object any object implementing the buffer API. an integer bytes:bytes(iterable_of_ints) -&gt; bytesbytes(string, encoding[, errors]) -&gt; bytesbytes(bytes_or_buffer) -&gt; immutable copy of bytes_or_bufferbytes(int) -&gt; bytes object of size given by the parameter initialized with null bytesbytes() -&gt; empty bytes objectConstruct an immutable array of bytes from: an iterable yielding integers in range(256) a text string encoded using the specified encoding any object implementing the buffer API. an integer classmethod:classmethod(function) -&gt; methodConvert a function to be a class method.A class method receives the class as implicit first argument,just like an instance method receives the instance.To declare a class method, use this idiom: class C: @classmethod def f(cls, arg1, arg2, …): …It can be called either on the class (e.g. C.f()) or on an instance(e.g. C().f()). The instance is ignored except for its class.If a class method is called for a derived class, the derived classobject is passed as the implied first argument.Class methods are different than C++ or Java static methods.If you want those, see the staticmethod builtin. complex:Create a complex number from a real part and an optional imaginary part.This is equivalent to (real + imag*1j) where imag defaults to 0. dict:dict() -&gt; new empty dictionarydict(mapping) -&gt; new dictionary initialized from a mapping object’s (key, value) pairsdict(iterable) -&gt; new dictionary initialized as if via: d &#x3D; {} for k, v in iterable: d[k] &#x3D; vdict(**kwargs) -&gt; new dictionary initialized with the name&#x3D;value pairs in the keyword argument list. For example: dict(one&#x3D;1, two&#x3D;2) enumerate:Return an enumerate object. iterable an object supporting iterationThe enumerate object yields pairs containing a count (from start, whichdefaults to zero) and a value yielded by the iterable argument.enumerate is useful for obtaining an indexed list: (0, seq[0]), (1, seq[1]), (2, seq[2]), … filter:filter(function or None, iterable) –&gt; filter objectReturn an iterator yielding those items of iterable for which function(item)is true. If function is None, return the items that are true. float:Convert a string or number to a floating point number, if possible. frozenset:frozenset() -&gt; empty frozenset objectfrozenset(iterable) -&gt; frozenset objectBuild an immutable unordered collection of unique elements. int:int([x]) -&gt; integerint(x, base&#x3D;10) -&gt; integerConvert a number or string to an integer, or return 0 if no argumentsare given. If x is a number, return x.int(). For floating pointnumbers, this truncates towards zero.If x is not a number or if base is given, then x must be a string,bytes, or bytearray instance representing an integer literal in thegiven base. The literal can be preceded by ‘+’ or ‘-‘ and be surroundedby whitespace. The base defaults to 10. Valid bases are 0 and 2-36.Base 0 means to interpret the base from the string as an integer literal.&gt;&gt;&gt; int(‘0b100’, base&#x3D;0)4 list:Built-in mutable sequence.If no argument is given, the constructor creates a new empty list.The argument must be an iterable if specified. map:map(func, *iterables) –&gt; map objectMake an iterator that computes the function using arguments fromeach of the iterables. Stops when the shortest iterable is exhausted. memoryview:Create a new memoryview object which references the given object. object:The base class of the class hierarchy.When called, it accepts no arguments and returns a new featurelessinstance that has no instance attributes and cannot be given any. property:Property attribute. fget function to be used for getting an attribute value fset function to be used for setting an attribute value fdel function to be used for del’ing an attribute doc docstringTypical use is to define a managed attribute x:class C(object): def getx(self): return self._x def setx(self, value): self._x &#x3D; value def delx(self): del self._x x &#x3D; property(getx, setx, delx, “I’m the ‘x’ property.”)Decorators make defining new properties or modifying existing ones easy:class C(object): @property def x(self): “I am the ‘x’ property.” return self._x @x.setter def x(self, value): self._x &#x3D; value @x.deleter def x(self): del self._x range:range(stop) -&gt; range objectrange(start, stop[, step]) -&gt; range objectReturn an object that produces a sequence of integers from start (inclusive)to stop (exclusive) by step. range(i, j) produces i, i+1, i+2, …, j-1.start defaults to 0, and stop is omitted! range(4) produces 0, 1, 2, 3.These are exactly the valid indices for a list of 4 elements.When step is given, it specifies the increment (or decrement). reversed:Return a reverse iterator over the values of the given sequence. set:set() -&gt; new empty set objectset(iterable) -&gt; new set objectBuild an unordered collection of unique elements. slice:slice(stop)slice(start, stop[, step])Create a slice object. This is used for extended slicing (e.g. a[0:10:2]). staticmethod:staticmethod(function) -&gt; methodConvert a function to be a static method.A static method does not receive an implicit first argument.To declare a static method, use this idiom: class C: @staticmethod def f(arg1, arg2, …): …It can be called either on the class (e.g. C.f()) or on an instance(e.g. C().f()). Both the class and the instance are ignored, andneither is passed implicitly as the first argument to the method.Static methods in Python are similar to those found in Java or C++.For a more advanced concept, see the classmethod builtin. str:str(object&#x3D;’’) -&gt; strstr(bytes_or_buffer[, encoding[, errors]]) -&gt; strCreate a new string object from the given object. If encoding orerrors is specified, then the object must expose a data bufferthat will be decoded using the given encoding and error handler.Otherwise, returns the result of object.str() (if defined)or repr(object).encoding defaults to sys.getdefaultencoding().errors defaults to ‘strict’. super:super() -&gt; same as super(class, )super(type) -&gt; unbound super objectsuper(type, obj) -&gt; bound super object; requires isinstance(obj, type)super(type, type2) -&gt; bound super object; requires issubclass(type2, type)Typical use to call a cooperative superclass method:class C(B): def meth(self, arg): super().meth(arg)This works for class methods too:class C(B): @classmethod def cmeth(cls, arg): super().cmeth(arg) tuple:Built-in immutable sequence.If no argument is given, the constructor returns an empty tuple.If iterable is specified the tuple is initialized from iterable’s items.If the argument is a tuple, the return value is the same object. type:type(object_or_name, bases, dict)type(object) -&gt; the object’s typetype(name, bases, dict) -&gt; a new type zip:zip(*iterables, strict&#x3D;False) –&gt; Yield tuples until an input is exhausted. &gt;&gt;&gt; list(zip(‘abcdefg’, range(3), range(4))) [(‘a’, 0, 0), (‘b’, 1, 1), (‘c’, 2, 2)]The zip object yields n-length tuples, where n is the number of iterablespassed as positional arguments to zip(). The i-th element in every tuplecomes from the i-th iterable argument to zip(). This continues until theshortest argument is exhausted.If strict is true and one of the arguments is exhausted before the others,raise a ValueError. 例外:ArithmeticError:Base class for arithmetic errors. AssertionError:Assertion failed. AttributeError:Attribute not found. BaseException:Common base class for all exceptions BlockingIOError:I&#x2F;O operation would block. BrokenPipeError:Broken pipe. BufferError:Buffer error. BytesWarning:Base class for warnings about bytes and buffer related problems, mostlyrelated to conversion from str or comparing to str. ChildProcessError:Child process error. ConnectionAbortedError:Connection aborted. ConnectionError:Connection error. ConnectionRefusedError:Connection refused. ConnectionResetError:Connection reset. DeprecationWarning:Base class for warnings about deprecated features. EOFError:Read beyond end of file. EncodingWarning:Base class for warnings about encodings. EnvironmentError:Base class for I&#x2F;O related errors. Exception:Common base class for all non-exit exceptions. FileExistsError:File already exists. FileNotFoundError:File not found. FloatingPointError:Floating point operation failed. FutureWarning:Base class for warnings about constructs that will change semanticallyin the future. GeneratorExit:Request that a generator exit. IOError:Base class for I&#x2F;O related errors. ImportError:Import can’t find module, or can’t find name in module. ImportWarning:Base class for warnings about probable mistakes in module imports IndentationError:Improper indentation. IndexError:Sequence index out of range. InterruptedError:Interrupted by signal. IsADirectoryError:Operation doesn’t work on directories. KeyError:Mapping key not found. KeyboardInterrupt:Program interrupted by user. LookupError:Base class for lookup errors. MemoryError:Out of memory. ModuleNotFoundError:Module not found. NameError:Name not found globally. NotADirectoryError:Operation only works on directories. NotImplementedError:Method or function hasn’t been implemented yet. OSError:Base class for I&#x2F;O related errors. OverflowError:Result too large to be represented. PendingDeprecationWarning:Base class for warnings about features which will be deprecatedin the future. PermissionError:Not enough permissions. ProcessLookupError:Process not found. RecursionError:Recursion limit exceeded. ReferenceError:Weak ref proxy used after referent went away. ResourceWarning:Base class for warnings about resource usage. RuntimeError:Unspecified run-time error. RuntimeWarning:Base class for warnings about dubious runtime behavior. StopAsyncIteration:Signal the end from iterator.anext(). StopIteration:Signal the end from iterator.next(). SyntaxError:Invalid syntax. SyntaxWarning:Base class for warnings about dubious syntax. SystemError:Internal error in the Python interpreter.Please report this to the Python maintainer, along with the traceback,the Python version, and the hardware&#x2F;OS platform and version. SystemExit:Request to exit from the interpreter. TabError:Improper mixture of spaces and tabs. TimeoutError:Timeout expired. TypeError:Inappropriate argument type. UnboundLocalError:Local name referenced but not bound to a value. UnicodeError:Unicode related error. UnicodeWarning:Base class for warnings about Unicode related problems, mostlyrelated to conversion problems. UserWarning:Base class for warnings generated by user code. ValueError:Inappropriate argument value (of correct type). Warning:Base class for warning categories. WindowsError:Base class for I&#x2F;O related errors. ZeroDivisionError:Second argument to a division or modulo operation was zero"},{"title":"Python 檔案輸出入","date":"2022-04-30T01:47:39.915Z","url":"/2022/04/30/io/","tags":[["programming,Python","/tags/programming-Python/"]],"categories":[[" ",""]],"content":"Python 檔案輸出入檔案處裡有三個步驟 開啟檔案 讀寫檔案 關閉檔案(可視情況省略) 開啟檔案開啟檔案的基本語法如下： 模式模式包含三個部分 開啟方式 名稱 符號 功能 讀取 r 讀取檔案，檔案必須存在 寫入 w 從檔案開頭開始寫入，若不存在則新建一個 新增 x 新建一個檔案並寫入，檔案必須不存在 附加 a 從檔案結尾開始寫入，檔案必須存在 讀寫格式 名稱 符號 功能 文字 t 用文字模式開啟，讀寫使用str型別 二進位 b 用二進位模式開啟，讀寫使用bytes型別 是否讀寫皆可讀寫皆可在結尾加一個”+” "},{"title":"Python matplotlib","date":"2022-04-30T01:47:28.912Z","url":"/2022/04/30/matplotlib/","tags":[["programming,Python,matplotlib","/tags/programming-Python-matplotlib/"]],"categories":[[" ",""]],"content":"matplotlib因為和通常numpy一起用，所以開頭要寫 初始化與顯示作法一：建立影像物件語法如下 fig可以換成其他名稱，以下使用fig指代影像物件建立完成繪圖物件再建立一個子圖 想像一個nrows橫行ncols直列的網格，並把axe放在index所指的位置注意此處座標&#x2F;索引皆由1開始而非由0開始如果不需要進行排版可以省略所有引數最後是顯示的部分 如果用的是Python console則會建立一個視窗來顯示圖表如果用的是Jupyter NoteBook&#x2F;JupyterLab則會顯示在建立fig和axe的那一個Cell下方(fig和axe要在同一個Cell建立，否則不會顯示)，且不需要執行此行若堅持要使用show，則在開頭加上 且此作法會導致程式建立一個視窗來顯示圖表 作法二：直接使用plt若不想要使用繪圖物件，可以把plt當成一個子圖來使用使用Jupyter NoteBook&#x2F;JupyterLab時建議使用此做法也可以建立個子圖 想像一個nrows橫行ncols直列的網格，並在index所指的位置建立子圖，使plt當成該子圖使用最後是顯示的部分 如果用的是Python console則會建立一個視窗來顯示圖表如果用的是Jupyter NoteBook&#x2F;JupyterLab則會顯示在下方 圖表繪製基本繪製折線圖 “資料”可以是list或是一維的numpy陣列資料可以不只一組，用來在一張圖中顯示多筆資料兩筆資料這樣寫： lines是一個儲存折線的列表，幾組資料就幾條折線 折線圖樣式 樣式是一個字串，由三個部分組成 1. 色彩字元 色彩字元|說明 ---|--- b|藍 g|綠 r|紅 c|青 m|洋紅 y|黃 k|黑 w|白 2. 線型字元 線型字元|說明 ---|--- -|實線 \\-\\-|短劃虛線 .|點虛線 -:|短劃點虛線 3. 符號字元 符號字元|說明 ---|--- .|點 ,|像素 o|圓形 s|方形 ^|三角形 Ex.藍色實線並用三角形符號記做 散佈圖 “資料”可以是list或是一維的numpy陣列，只能有一組“點大小”和”色彩”是和資料長度相同的list或是一維的numpy陣列scatter指令可重複執行來疊加資料 長條圖垂直： 水平： 索引用來表示資料的顯示順序索引通常為 bar指令可重複執行來疊加資料並按照索引排列 直方圖 “資料”可以是list或是一維的numpy陣列，只能有一組 圓餅圖 圖例在繪製任何資料時，都可在結尾加上label=&quot;xxx&quot;來設置資料集名稱如： 並使用 顯示圖例 標籤 外觀 多軸圖表要建立多軸圖表可以用 建立一個與原來子圖共用x軸的子圖再分別對兩個子圖做操作即可"},{"title":"python numpy","date":"2022-04-30T01:47:17.138Z","url":"/2022/04/30/numpy/","tags":[["programming,Python,numpy","/tags/programming-Python-numpy/"]],"categories":[[" ",""]],"content":"numpyNumPy是Python語言的一個擴充程式庫。支援高階大量的維度陣列與矩陣運算，此外也針對陣列運算提供大量的數學函式函式庫。通常使用”import numpy as np”來載入numpy簡寫：np -&gt; numpyarr -&gt; numpy 陣列arr{type} -&gt; 數據類型為type 的 numpy 陣列pyarr -&gt; 基於python list 的陣列(有時也可以是可迭代物件)shape -&gt; 陣列形狀，使用n個數字的元組表示n維陣列大小，或使用單個數字表示一維陣列大小dtype -&gt; numpy數據類型，為np.dtype物件value -&gt; numpy陣列中的資料，由陣列的數據類型決定實際型別 numpy基本常數np.version: strnumpy版本np.nan: float獲取NaNnp.inf: float獲取Infinity numpy常用函數–陣列生成–(未指定類型則默認為np.float64)np.array(pyarr, dtype&#x3D;{dtype}) -&gt; arr將python 陣列轉換為numpy陣列，依據原始陣列資料決定默認數據類型，內容只能是數字默認索引是從零開始，就和一般的陣列一樣np.zeros(shape, dtype&#x3D;{dtype}) -&gt; arr生成全部是0的numpy陣列，默認數據類型為float64np.ones(shape, dtype&#x3D;{dtype}) -&gt; arr生成全部是1的numpy陣列，默認數據類型為float64np.full(shape, value, dtype&#x3D;{dtype}) -&gt; arr生成全部是value的numpy陣列，依據value決定默認數據類型np.zeros_like(arr, dtype&#x3D;{dtype}) -&gt; arr生成全部是0的numpy陣列，形狀與arr相同，默認數據類型為float64np.ones_like(arr, dtype&#x3D;{dtype}) -&gt; arr生成全部是0的numpy陣列，形狀與arr相同，默認數據類型為float64np.arange(end:int)&#x2F;np.arange(start:int,end:int,step:int) -&gt; arr行為類似range()，生成一維的numpy陣列，默認數據類型為int32np.linspace(start: int|float|complex,stop: int|float|complex, num: int) -&gt; arr以start為開頭stop為結尾建立長度為num的等差數列np.eye(size:int) -&gt; arr生成邊長size的矩陣，且只有x&#x3D;y的格子是一，其他為零(單位矩陣)np.random.randint(min:int,max:int,shape)生成 $[min,max)$ 的整數陣列，默認數據類型為int32np.random.rand(*shape)生成 0~1 的浮點數陣列，默認數據類型為float64此處shape需將各個緯度大小分開寫，如：np.random.rand(3,7,5)若要堅持使用tuple可以使用星號，如：np.random.rand(*(3,7,5))np.random.randn(*shape)生成 標準常態分配 的浮點數陣列，默認數據類型為float64 –陣列處理–np.diag(arr&#x2F;pyarr,k: int) -&gt; arrk表示偏移量，正表示向右、負表示向下，默認為0case 1:原陣列為一維：將原陣列的元素由左上到左下排列於新矩陣中，新矩陣邊長為len(原陣列)+abs(k)case 2:原陣列為二維(不一定是矩陣)：將原陣列的元素由左上到左下取出於新一維陣列中np.tile(arr,shape) -&gt; arr將矩陣倍增shape倍np.dot(arr1,arr2) -&gt; arrcase 1:原陣列為一維：向量內積case 2:原陣列為二維：矩陣乘法np.intersect1d(arr1,arr2) -&gt; arr取出同時存在於兩陣列的值 –其他–np.nonzero(arr&#x2F;pyarr) -&gt; tuple[arr]尋找陣列中的非零項目(對bool則是!&#x3D;False)，用n個一維的numpy陣列紀錄n維陣列非零項目位置，一維的numpy陣列維非零項目總數，默認數據類型為int64np.unravel_index(index:int,shape) -&gt; shape將index轉換為大小為shape的矩陣中的位置座標 numpy數據類型numpy數據類型多用來標示陣列的數據類型以下為基礎數據類型，實際使用須加上”np.”前綴bool_ 布爾型數據類型（True 或者 False）數學運算時True視為1，False視為0int_ 默認的整數類型（類似於 C 語言中的 long，int32 或 int64）intc 與 C 的 int 類型一樣，一般是 int32 或 int 64intp 用於索引的整數類型（類似於 C 的 ssize_t，一般情況下仍然是 int32 或 int64）int8 字節（-128 to 127）int16 整數（-32768 to 32767）int32 整數（-2147483648 to 2147483647）int64 整數（-9223372036854775808 to 9223372036854775807）uint8 無符號整數（0 to 255）uint16 無符號整數（0 to 65535）uint32 無符號整數（0 to 4294967295）uint64 無符號整數（0 to 18446744073709551615）float_ float64 類型的簡寫float16 半精度浮點數，包括：1 個符號位，5 個指數位，10 個尾數位float32 單精度浮點數，包括：1 個符號位，8 個指數位，23 個尾數位float64 雙精度浮點數，包括：1 個符號位，11 個指數位，52 個尾數位complex_ complex128 類型的簡寫，即 128 位複數complex64 複數，表示雙 32 位浮點數（實數部分和虛數部分）complex128 複數，表示雙 64 位浮點數（實數部分和虛數部分） 在指定數據類型，使用python傳統類型的結果：bool -&gt; np.bool_int -&gt; np.int_ -&gt; np.int32float -&gt; np.float_ -&gt; np.float64complex -&gt; np.complex_ -&gt; np.complex128 陣列方法及屬性陣列基礎運算對於多數陣列基礎計算，有下列三種情形：number {運算子} arrarr {運算子} numberarr {運算子} arr若是陣列與數字運算，將陣列個別元素與數字進行運算後，生成相同形狀的矩陣若是陣列與陣列運算，將陣列對應元素分別進行運算後，生成相同形狀的矩陣，兩陣列形狀需相同，否則拋出ValueError完全符合此規則的運算子：“+” “-“ “*“ “&#x2F;“ “&#x2F;&#x2F;“ “&lt;&lt;” “&gt;&gt;” “==“ “!=“ “&lt;=“ “&gt;=“ “&gt;” “&lt;” “|” “&amp;” “^”注：比較兩布林陣列需使用”|”, “&amp;”, “^”等運算子，不可使用”and”, “or” 陣列元素讀寫讀取：數據 &#x3D; arr[索引]此處數據可能是單一數值或陣列，視索引而定寫入：arr[索引] &#x3D; 數據此處數據可以是單一數值或陣列。1.若索引指向非單一數值，數據可以選擇輸入單一數值或與索引指向的內容相同形狀的陣列，若輸入單一數值，則將索引指向的內容全部改為該數值，若輸入與索引指向的內容相同形狀的陣列，則將索引指向的內容改為對應位置的值2.若索引指向單一數值，數據只能是單一數值 索引表示法1.依坐標軸填入索引 依坐標軸填入、缺少的部分自動填上None，但最好自己加(會和4.搞混) 每個座標軸中可填入的參數如下： a.純數值 整數，表示座標，可用負值表示倒數第幾個 b.slice c.list/tuple(在陣列不只一維時才能用，否則會和3.搞混)/arr(一維) d.range e.ellipsis&#x2F;None 取全部，與slice(None,None,None)同義2.使用與原陣列形狀相同的布林陣列這種用法中的布林陣列通常是使用原陣列生成例如：取出正數 3.複合索引(使用tuple)把1.打包成一個tuple來和4.合用4.多重索引(使用list或與2.&#x2F;3.合用)將多個結果並列儲存在一個陣列裡輸出其中每一個索引必須指向相同形狀的陣列否則即使有加中括號也會被視為1.與2.&#x2F;3.合用可省略list的外框，但建議不要省略(會和1.搞混) 陣列屬性arr.shape: tuple陣列形狀arr.size: int陣列元素數目(同len(arr))arr.dtype: dtype陣列數值類型arr.itemsize: int單個元素占用的位元組數arr.nbytes: int整個陣列占用的位元組數arr.ndim: int陣列維度數，同len(arr.shape)arr.T: arr轉置矩陣 陣列方法arr.resize(shape) -&gt; None在不改變陣列元素數目的前提下，改變原陣列形狀arr.reshape(shape) -&gt; arr在不改變陣列元素數目的前提下，生成形狀不同的陣列arr.min() -&gt; value陣列中最小的元素arr.max() -&gt; value陣列中最大的元素arr.mean() -&gt; value陣列所有所有元素的平均值若原陣列的數據類型為布林值或整數，則回傳值可能與原數據類型不同(多為float)arr.argmin() -&gt; int陣列中最小的元素的索引arr.argmax() -&gt; int陣列中最大的元素的索引 help class ndarray(builtins.object) ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using `array`, `zeros` or `empty` (refer to the See Also section below). The parameters given here refer to a low-level method (`ndarray(...)`) for instantiating an array. For more information, refer to the `numpy` module and examine the methods and attributes of an array. Parameters ---------- (for the \\_\\_new__ method; see Notes below) shape : tuple of ints Shape of created array. dtype : data-type, optional Any object that can be interpreted as a numpy data type. buffer : object exposing buffer interface, optional Used to fill the array with data. offset : int, optional Offset of array data in buffer. strides : tuple of ints, optional Strides of data in memory. order : {'C', 'F'}, optional Row-major (C-style) or column-major (Fortran-style) order. Attributes ---------- T : ndarray Transpose of the array. data : buffer The array's elements, in memory. dtype : dtype object Describes the format of the elements in the array. flags : dict Dictionary containing information related to memory use, e.g., 'C_CONTIGUOUS', 'OWNDATA', 'WRITEABLE', etc. flat : numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., ``x.flat = 3`` (See `ndarray.flat` for assignment examples; TODO). imag : ndarray Imaginary part of the array. real : ndarray Real part of the array. size : int Number of elements in the array. itemsize : int The memory use of each array element in bytes. nbytes : int The total number of bytes required to store the array data, i.e., ``itemsize * size``. ndim : int The array's number of dimensions. shape : tuple of ints Shape of the array. strides : tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous ``(3, 4)`` array of type ``int16`` in C-order has strides ``(8, 2)``. This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time (``2 * 4``). ctypes : ctypes object Class containing properties of the array needed for interaction with ctypes. base : ndarray If the array is a view into another array, that array is its `base` (unless that array is also a view). The `base` array is where the array data is actually stored. See Also -------- array : Construct an array. zeros : Create an array, each element of which is zero. empty : Create an array, but leave its allocated memory unchanged (i.e., it contains \"garbage\"). dtype : Create a data-type. numpy.typing.NDArray : A :term:`generic ` version of ndarray. Notes ----- There are two modes of creating an array using ``__new__``: 1. If `buffer` is None, then only `shape`, `dtype`, and `order` are used. 2. If `buffer` is an object exposing the buffer interface, then all keywords are interpreted. No ``__init__`` method is needed because the array is fully initialized after the ``__new__`` method. Examples -------- These examples illustrate the low-level `ndarray` constructor. Refer to the `See Also` section above for easier ways of constructing an ndarray. First mode, `buffer` is None: >>> np.ndarray(shape=(2,2), dtype=float, order='F') array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: >>> np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3]) Methods defined here: \\_\\_abs \\_\\_(self, /) abs(self) \\_\\_add \\_\\_(self, value, /) Return self+value. \\_\\_and \\_\\_(self, value, /) Return self&value. \\_\\_array \\_\\_(...) a.__array \\_\\_([dtype], /) -> reference if type unchanged, copy otherwise. Returns either a new reference to self if dtype is not given or a new array of provided data type if dtype is different from the current dtype of the array. \\_\\_array_function \\_\\_(...) \\_\\_array_prepare \\_\\_(...) a.__array_prepare \\_\\_(obj) -> Object of same type as ndarray object obj. \\_\\_array_ufunc \\_\\_(...) \\_\\_array_wrap \\_\\_(...) a.__array_wrap \\_\\_(obj) -> Object of same type as ndarray object a. \\_\\_bool \\_\\_(self, /) self != 0 \\_\\_complex \\_\\_(...) \\_\\_contains \\_\\_(self, key, /) Return key in self. \\_\\_copy \\_\\_(...) a.__copy \\_\\_() Used if :func:`copy.copy` is called on an array. Returns a copy of the array. Equivalent to ``a.copy(order='K')``. \\_\\_deepcopy \\_\\_(...) a.__deepcopy \\_\\_(memo, /) -> Deep copy of array. Used if :func:`copy.deepcopy` is called on an array. \\_\\_delitem \\_\\_(self, key, /) Delete self[key]. \\_\\_divmod \\_\\_(self, value, /) Return divmod(self, value). \\_\\_eq \\_\\_(self, value, /) Return self==value. \\_\\_float \\_\\_(self, /) float(self) \\_\\_floordiv \\_\\_(self, value, /) Return self//value. \\_\\_format \\_\\_(...) Default object formatter. \\_\\_ge \\_\\_(self, value, /) Return self>=value. \\_\\_getitem \\_\\_(self, key, /) Return self[key]. \\_\\_gt \\_\\_(self, value, /) Return self>value. \\_\\_iadd \\_\\_(self, value, /) Return self+=value. \\_\\_iand \\_\\_(self, value, /) Return self&=value. \\_\\_ifloordiv \\_\\_(self, value, /) Return self//=value. \\_\\_ilshift \\_\\_(self, value, /) Return self=value. \\_\\_isub \\_\\_(self, value, /) Return self-=value. \\_\\_iter \\_\\_(self, /) Implement iter(self). \\_\\_itruediv \\_\\_(self, value, /) Return self/=value. \\_\\_ixor \\_\\_(self, value, /) Return self^=value. \\_\\_le \\_\\_(self, value, /) Return self> x = np.array([1, 2, 2.5]) >>> x array([1. , 2. , 2.5]) >>> x.astype(int) array([1, 2, 2]) byteswap(...) a.byteswap(inplace=False) Swap the bytes of the array elements Toggle between low-endian and big-endian data representation by returning a byteswapped array, optionally swapped in-place. Arrays of byte-strings are not swapped. The real and imaginary parts of a complex number are swapped individually. Parameters ---------- inplace : bool, optional If ``True``, swap bytes in-place, default is ``False``. Returns ------- out : ndarray The byteswapped array. If `inplace` is ``True``, this is a view to self. Examples -------- >>> A = np.array([1, 256, 8755], dtype=np.int16) >>> list(map(hex, A)) ['0x1', '0x100', '0x2233'] >>> A.byteswap(inplace=True) array([ 256, 1, 13090], dtype=int16) >>> list(map(hex, A)) ['0x100', '0x1', '0x3322'] Arrays of byte-strings are not swapped >>> A = np.array([b'ceg', b'fac']) >>> A.byteswap() array([b'ceg', b'fac'], dtype='|S3') ``A.newbyteorder().byteswap()`` produces an array with the same values but different representation in memory >>> A = np.array([1, 2, 3]) >>> A.view(np.uint8) array([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], dtype=uint8) >>> A.newbyteorder().byteswap(inplace=True) array([1, 2, 3]) >>> A.view(np.uint8) array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3], dtype=uint8) choose(...) a.choose(choices, out=None, mode='raise') Use an index array to construct a new array from a set of choices. Refer to `numpy.choose` for full documentation. See Also -------- numpy.choose : equivalent function clip(...) a.clip(min=None, max=None, out=None, **kwargs) Return an array whose values are limited to ``[min, max]``. One of max or min must be given. Refer to `numpy.clip` for full documentation. See Also -------- numpy.clip : equivalent function compress(...) a.compress(condition, axis=None, out=None) Return selected slices of this array along given axis. Refer to `numpy.compress` for full documentation. See Also -------- numpy.compress : equivalent function conj(...) a.conj() Complex-conjugate all elements. Refer to `numpy.conjugate` for full documentation. See Also -------- numpy.conjugate : equivalent function conjugate(...) a.conjugate() Return the complex conjugate, element-wise. Refer to `numpy.conjugate` for full documentation. See Also -------- numpy.conjugate : equivalent function copy(...) a.copy(order='C') Return a copy of the array. Parameters ---------- order : {'C', 'F', 'A', 'K'}, optional Controls the memory layout of the copy. 'C' means C-order, 'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous, 'C' otherwise. 'K' means match the layout of `a` as closely as possible. (Note that this function and :func:`numpy.copy` are very similar but have different default values for their order= arguments, and this function always passes sub-classes through.) See also -------- numpy.copy : Similar function with different default behavior numpy.copyto Notes ----- This function is the preferred method for creating an array copy. The function :func:`numpy.copy` is similar, but it defaults to using order 'K', and will not pass sub-classes through by default. Examples -------- >>> x = np.array([[1,2,3],[4,5,6]], order='F') >>> y = x.copy() >>> x.fill(0) >>> x array([[0, 0, 0], [0, 0, 0]]) >>> y array([[1, 2, 3], [4, 5, 6]]) >>> y.flags['C_CONTIGUOUS'] True cumprod(...) a.cumprod(axis=None, dtype=None, out=None) Return the cumulative product of the elements along the given axis. Refer to `numpy.cumprod` for full documentation. See Also -------- numpy.cumprod : equivalent function cumsum(...) a.cumsum(axis=None, dtype=None, out=None) Return the cumulative sum of the elements along the given axis. Refer to `numpy.cumsum` for full documentation. See Also -------- numpy.cumsum : equivalent function diagonal(...) a.diagonal(offset=0, axis1=0, axis2=1) Return specified diagonals. In NumPy 1.9 the returned array is a read-only view instead of a copy as in previous NumPy versions. In a future version the read-only restriction will be removed. Refer to :func:`numpy.diagonal` for full documentation. See Also -------- numpy.diagonal : equivalent function dot(...) a.dot(b, out=None) Dot product of two arrays. Refer to `numpy.dot` for full documentation. See Also -------- numpy.dot : equivalent function Examples -------- >>> a = np.eye(2) >>> b = np.ones((2, 2)) * 2 >>> a.dot(b) array([[2., 2.], [2., 2.]]) This array method can be conveniently chained: >>> a.dot(b).dot(b) array([[8., 8.], [8., 8.]]) dump(...) a.dump(file) Dump a pickle of the array to the specified file. The array can be read back with pickle.load or numpy.load. Parameters ---------- file : str or Path A string naming the dump file. .. versionchanged:: 1.17.0 `pathlib.Path` objects are now accepted. dumps(...) a.dumps() Returns the pickle of the array as a string. pickle.loads or numpy.loads will convert the string back to an array. Parameters ---------- None fill(...) a.fill(value) Fill the array with a scalar value. Parameters ---------- value : scalar All elements of `a` will be assigned this value. Examples -------- >>> a = np.array([1, 2]) >>> a.fill(0) >>> a array([0, 0]) >>> a = np.empty(2) >>> a.fill(1) >>> a array([1., 1.]) flatten(...) a.flatten(order='C') Return a copy of the array collapsed into one dimension. Parameters ---------- order : {'C', 'F', 'A', 'K'}, optional 'C' means to flatten in row-major (C-style) order. 'F' means to flatten in column-major (Fortran- style) order. 'A' means to flatten in column-major order if `a` is Fortran *contiguous* in memory, row-major order otherwise. 'K' means to flatten `a` in the order the elements occur in memory. The default is 'C'. Returns ------- y : ndarray A copy of the input array, flattened to one dimension. See Also -------- ravel : Return a flattened array. flat : A 1-D flat iterator over the array. Examples -------- >>> a = np.array([[1,2], [3,4]]) >>> a.flatten() array([1, 2, 3, 4]) >>> a.flatten('F') array([1, 3, 2, 4]) getfield(...) a.getfield(dtype, offset=0) Returns a field of the given array as a certain type. A field is a view of the array data with a given data-type. The values in the view are determined by the given type and the offset into the current array in bytes. The offset needs to be such that the view dtype fits in the array dtype; for example an array of dtype complex128 has 16-byte elements. If taking a view with a 32-bit integer (4 bytes), the offset needs to be between 0 and 12 bytes. Parameters ---------- dtype : str or dtype The data type of the view. The dtype size of the view can not be larger than that of the array itself. offset : int Number of bytes to skip before beginning the element view. Examples -------- >>> x = np.diag([1.+1.j]*2) >>> x[1, 1] = 2 + 4.j >>> x array([[1.+1.j, 0.+0.j], [0.+0.j, 2.+4.j]]) >>> x.getfield(np.float64) array([[1., 0.], [0., 2.]]) By choosing an offset of 8 bytes we can select the complex part of the array for our view: >>> x.getfield(np.float64, offset=8) array([[1., 0.], [0., 4.]]) item(...) a.item(*args) Copy an element of an array to a standard Python scalar and return it. Parameters ---------- \\*args : Arguments (variable number and type) * none: in this case, the method only works for arrays with one element (`a.size == 1`), which element is copied into a standard Python scalar object and returned. * int_type: this argument is interpreted as a flat index into the array, specifying which element to copy and return. * tuple of int_types: functions as does a single int_type argument, except that the argument is interpreted as an nd-index into the array. Returns ------- z : Standard Python scalar object A copy of the specified element of the array as a suitable Python scalar Notes ----- When the data type of `a` is longdouble or clongdouble, item() returns a scalar array object because there is no available Python scalar that would not lose information. Void arrays return a buffer object for item(), unless fields are defined, in which case a tuple is returned. `item` is very similar to a[args], except, instead of an array scalar, a standard Python scalar is returned. This can be useful for speeding up access to elements of the array and doing arithmetic on elements of the array using Python's optimized math. Examples -------- >>> np.random.seed(123) >>> x = np.random.randint(9, size=(3, 3)) >>> x array([[2, 2, 6], [1, 3, 6], [1, 0, 1]]) >>> x.item(3) 1 >>> x.item(7) 0 >>> x.item((0, 1)) 2 >>> x.item((2, 2)) 1 itemset(...) a.itemset(*args) Insert scalar into an array (scalar is cast to array's dtype, if possible) There must be at least 1 argument, and define the last argument as *item*. Then, ``a.itemset(*args)`` is equivalent to but faster than ``a[args] = item``. The item should be a scalar value and `args` must select a single item in the array `a`. Parameters ---------- \\*args : Arguments If one argument: a scalar, only used in case `a` is of size 1. If two arguments: the last argument is the value to be set and must be a scalar, the first argument specifies a single array element location. It is either an int or a tuple. Notes ----- Compared to indexing syntax, `itemset` provides some speed increase for placing a scalar into a particular location in an `ndarray`, if you must do this. However, generally this is discouraged: among other problems, it complicates the appearance of the code. Also, when using `itemset` (and `item`) inside a loop, be sure to assign the methods to a local variable to avoid the attribute look-up at each loop iteration. Examples -------- >>> np.random.seed(123) >>> x = np.random.randint(9, size=(3, 3)) >>> x array([[2, 2, 6], [1, 3, 6], [1, 0, 1]]) >>> x.itemset(4, 0) >>> x.itemset((2, 2), 9) >>> x array([[2, 2, 6], [1, 0, 6], [1, 0, 9]]) max(...) a.max(axis=None, out=None, keepdims=False, initial=, where=True) Return the maximum along a given axis. Refer to `numpy.amax` for full documentation. See Also -------- numpy.amax : equivalent function mean(...) a.mean(axis=None, dtype=None, out=None, keepdims=False, *, where=True) Returns the average of the array elements along given axis. Refer to `numpy.mean` for full documentation. See Also -------- numpy.mean : equivalent function min(...) a.min(axis=None, out=None, keepdims=False, initial=, where=True) Return the minimum along a given axis. Refer to `numpy.amin` for full documentation. See Also -------- numpy.amin : equivalent function newbyteorder(...) arr.newbyteorder(new_order='S', /) Return the array with the same data viewed with a different byte order. Equivalent to:: arr.view(arr.dtype.newbytorder(new_order)) Changes are also made in all fields and sub-arrays of the array data type. Parameters ---------- new_order : string, optional Byte order to force; a value from the byte order specifications below. `new_order` codes can be any of: * 'S' - swap dtype from current to opposite endian * {'', 'big'} - big endian * '=' - native order, equivalent to `sys.byteorder` * {'|', 'I'} - ignore (no change to byte order) The default value ('S') results in swapping the current byte order. Returns ------- new_arr : array New array object with the dtype reflecting given change to the byte order. nonzero(...) a.nonzero() Return the indices of the elements that are non-zero. Refer to `numpy.nonzero` for full documentation. See Also -------- numpy.nonzero : equivalent function partition(...) a.partition(kth, axis=-1, kind='introselect', order=None) Rearranges the elements in the array in such a way that the value of the element in kth position is in the position it would be in a sorted array. All elements smaller than the kth element are moved before this element and all equal or greater are moved behind it. The ordering of the elements in the two partitions is undefined. .. versionadded:: 1.8.0 Parameters ---------- kth : int or sequence of ints Element index to partition by. The kth element value will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order of all elements in the partitions is undefined. If provided with a sequence of kth it will partition all elements indexed by kth of them into their sorted position at once. axis : int, optional Axis along which to sort. Default is -1, which means sort along the last axis. kind : {'introselect'}, optional Selection algorithm. Default is 'introselect'. order : str or list of str, optional When `a` is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need to be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. See Also -------- numpy.partition : Return a parititioned copy of an array. argpartition : Indirect partition. sort : Full sort. Notes ----- See ``np.partition`` for notes on the different algorithms. Examples -------- >>> a = np.array([3, 4, 2, 1]) >>> a.partition(3) >>> a array([2, 1, 3, 4]) >>> a.partition((1, 3)) >>> a array([1, 2, 3, 4]) prod(...) a.prod(axis=None, dtype=None, out=None, keepdims=False, initial=1, where=True) Return the product of the array elements over the given axis Refer to `numpy.prod` for full documentation. See Also -------- numpy.prod : equivalent function ptp(...) a.ptp(axis=None, out=None, keepdims=False) Peak to peak (maximum - minimum) value along a given axis. Refer to `numpy.ptp` for full documentation. See Also -------- numpy.ptp : equivalent function put(...) a.put(indices, values, mode='raise') Set ``a.flat[n] = values[n]`` for all `n` in indices. Refer to `numpy.put` for full documentation. See Also -------- numpy.put : equivalent function ravel(...) a.ravel([order]) Return a flattened array. Refer to `numpy.ravel` for full documentation. See Also -------- numpy.ravel : equivalent function ndarray.flat : a flat iterator on the array. repeat(...) a.repeat(repeats, axis=None) Repeat elements of an array. Refer to `numpy.repeat` for full documentation. See Also -------- numpy.repeat : equivalent function reshape(...) a.reshape(shape, order='C') Returns an array containing the same data with a new shape. Refer to `numpy.reshape` for full documentation. See Also -------- numpy.reshape : equivalent function Notes ----- Unlike the free function `numpy.reshape`, this method on `ndarray` allows the elements of the shape parameter to be passed in as separate arguments. For example, ``a.reshape(10, 11)`` is equivalent to ``a.reshape((10, 11))``. resize(...) a.resize(new_shape, refcheck=True) Change shape and size of array in-place. Parameters ---------- new_shape : tuple of ints, or `n` ints Shape of resized array. refcheck : bool, optional If False, reference count will not be checked. Default is True. Returns ------- None Raises ------ ValueError If `a` does not own its own data or references or views to it exist, and the data memory must be changed. PyPy only: will always raise if the data memory must be changed, since there is no reliable way to determine if references or views to it exist. SystemError If the `order` keyword argument is specified. This behaviour is a bug in NumPy. See Also -------- resize : Return a new array with the specified shape. Notes ----- This reallocates space for the data area if necessary. Only contiguous arrays (data elements consecutive in memory) can be resized. The purpose of the reference count check is to make sure you do not use this array as a buffer for another Python object and then reallocate the memory. However, reference counts can increase in other ways so if you are sure that you have not shared the memory for this array with another Python object, then you may safely set `refcheck` to False. Examples -------- Shrinking an array: array is flattened (in the order that the data are stored in memory), resized, and reshaped: >>> a = np.array([[0, 1], [2, 3]], order='C') >>> a.resize((2, 1)) >>> a array([[0], [1]]) >>> a = np.array([[0, 1], [2, 3]], order='F') >>> a.resize((2, 1)) >>> a array([[0], [2]]) Enlarging an array: as above, but missing entries are filled with zeros: >>> b = np.array([[0, 1], [2, 3]]) >>> b.resize(2, 3) # new_shape parameter doesn't have to be a tuple >>> b array([[0, 1, 2], [3, 0, 0]]) Referencing an array prevents resizing... >>> c = a >>> a.resize((1, 1)) Traceback (most recent call last): ... ValueError: cannot resize an array that references or is referenced ... Unless `refcheck` is False: >>> a.resize((1, 1), refcheck=False) >>> a array([[0]]) >>> c array([[0]]) round(...) a.round(decimals=0, out=None) Return `a` with each element rounded to the given number of decimals. Refer to `numpy.around` for full documentation. See Also -------- numpy.around : equivalent function searchsorted(...) a.searchsorted(v, side='left', sorter=None) Find indices where elements of v should be inserted in a to maintain order. For full documentation, see `numpy.searchsorted` See Also -------- numpy.searchsorted : equivalent function setfield(...) a.setfield(val, dtype, offset=0) Put a value into a specified place in a field defined by a data-type. Place `val` into `a`'s field defined by `dtype` and beginning `offset` bytes into the field. Parameters ---------- val : object Value to be placed in field. dtype : dtype object Data-type of the field in which to place `val`. offset : int, optional The number of bytes into the field at which to place `val`. Returns ------- None See Also -------- getfield Examples -------- >>> x = np.eye(3) >>> x.getfield(np.float64) array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]]) >>> x.setfield(3, np.int32) >>> x.getfield(np.int32) array([[3, 3, 3], [3, 3, 3], [3, 3, 3]], dtype=int32) >>> x array([[1.0e+000, 1.5e-323, 1.5e-323], [1.5e-323, 1.0e+000, 1.5e-323], [1.5e-323, 1.5e-323, 1.0e+000]]) >>> x.setfield(np.eye(3), np.int32) >>> x array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]]) setflags(...) a.setflags(write=None, align=None, uic=None) Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively. These Boolean-valued flags affect how numpy interprets the memory area used by `a` (see Notes below). The ALIGNED flag can only be set to True if the data is actually aligned according to the type. The WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set to True. The flag WRITEABLE can only be set to True if the array owns its own memory, or the ultimate owner of the memory exposes a writeable buffer interface, or is a string. (The exception for string is made so that unpickling can be done without copying memory.) Parameters ---------- write : bool, optional Describes whether or not `a` can be written to. align : bool, optional Describes whether or not `a` is aligned properly for its type. uic : bool, optional Describes whether or not `a` is a copy of another \"base\" array. Notes ----- Array flags provide information about how the memory area used for the array is to be interpreted. There are 7 Boolean flags in use, only four of which can be changed by the user: WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED. WRITEABLE (W) the data area can be written to; ALIGNED (A) the data and strides are aligned appropriately for the hardware (as determined by the compiler); UPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY; WRITEBACKIFCOPY (X) this array is a copy of some other array (referenced by .base). When the C-API function PyArray_ResolveWritebackIfCopy is called, the base array will be updated with the contents of this array. All flags can be accessed using the single (upper case) letter as well as the full name. Examples -------- >>> y = np.array([[3, 1, 7], ... [2, 0, 0], ... [8, 5, 9]]) >>> y array([[3, 1, 7], [2, 0, 0], [8, 5, 9]]) >>> y.flags C_CONTIGUOUS : True F_CONTIGUOUS : False OWNDATA : True WRITEABLE : True ALIGNED : True WRITEBACKIFCOPY : False UPDATEIFCOPY : False >>> y.setflags(write=0, align=0) >>> y.flags C_CONTIGUOUS : True F_CONTIGUOUS : False OWNDATA : True WRITEABLE : False ALIGNED : False WRITEBACKIFCOPY : False UPDATEIFCOPY : False >>> y.setflags(uic=1) Traceback (most recent call last): File \"\", line 1, in ValueError: cannot set WRITEBACKIFCOPY flag to True sort(...) a.sort(axis=-1, kind=None, order=None) Sort an array in-place. Refer to `numpy.sort` for full documentation. Parameters ---------- axis : int, optional Axis along which to sort. Default is -1, which means sort along the last axis. kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional Sorting algorithm. The default is 'quicksort'. Note that both 'stable' and 'mergesort' use timsort under the covers and, in general, the actual implementation will vary with datatype. The 'mergesort' option is retained for backwards compatibility. .. versionchanged:: 1.15.0 The 'stable' option was added. order : str or list of str, optional When `a` is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. See Also -------- numpy.sort : Return a sorted copy of an array. numpy.argsort : Indirect sort. numpy.lexsort : Indirect stable sort on multiple keys. numpy.searchsorted : Find elements in sorted array. numpy.partition: Partial sort. Notes ----- See `numpy.sort` for notes on the different sorting algorithms. Examples -------- >>> a = np.array([[1,4], [3,1]]) >>> a.sort(axis=1) >>> a array([[1, 4], [1, 3]]) >>> a.sort(axis=0) >>> a array([[1, 3], [1, 4]]) Use the `order` keyword to specify a field to use when sorting a structured array: >>> a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)]) >>> a.sort(order='y') >>> a array([(b'c', 1), (b'a', 2)], dtype=[('x', 'S1'), ('y', '>> x = np.array([[0, 1], [2, 3]], dtype='>> a = np.uint32([1, 2]) >>> a_list = list(a) >>> a_list [1, 2] >>> type(a_list[0]) >>> a_tolist = a.tolist() >>> a_tolist [1, 2] >>> type(a_tolist[0]) Additionally, for a 2D array, ``tolist`` applies recursively: >>> a = np.array([[1, 2], [3, 4]]) >>> list(a) [array([1, 2]), array([3, 4])] >>> a.tolist() [[1, 2], [3, 4]] The base case for this recursion is a 0D array: >>> a = np.array(1) >>> list(a) Traceback (most recent call last): ... TypeError: iteration over a 0-d array >>> a.tolist() 1 tostring(...) a.tostring(order='C') A compatibility alias for `tobytes`, with exactly the same behavior. Despite its name, it returns `bytes` not `str`\\ s. .. deprecated:: 1.19.0 trace(...) a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None) Return the sum along diagonals of the array. Refer to `numpy.trace` for full documentation. See Also -------- numpy.trace : equivalent function transpose(...) a.transpose(*axes) Returns a view of the array with axes transposed. For a 1-D array this has no effect, as a transposed vector is simply the same vector. To convert a 1-D array into a 2D column vector, an additional dimension must be added. `np.atleast2d(a).T` achieves this, as does `a[:, np.newaxis]`. For a 2-D array, this is a standard matrix transpose. For an n-D array, if axes are given, their order indicates how the axes are permuted (see Examples). If axes are not provided and ``a.shape = (i[0], i[1], ... i[n-2], i[n-1])``, then ``a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])``. Parameters ---------- axes : None, tuple of ints, or `n` ints * None or no argument: reverses the order of the axes. * tuple of ints: `i` in the `j`-th place in the tuple means `a`'s `i`-th axis becomes `a.transpose()`'s `j`-th axis. * `n` ints: same as an n-tuple of the same ints (this form is intended simply as a \"convenience\" alternative to the tuple form) Returns ------- out : ndarray View of `a`, with axes suitably permuted. See Also -------- transpose : Equivalent function ndarray.T : Array property returning the array transposed. ndarray.reshape : Give a new shape to an array without changing its data. Examples -------- >>> a = np.array([[1, 2], [3, 4]]) >>> a array([[1, 2], [3, 4]]) >>> a.transpose() array([[1, 3], [2, 4]]) >>> a.transpose((1, 0)) array([[1, 3], [2, 4]]) >>> a.transpose(1, 0) array([[1, 3], [2, 4]]) var(...) a.var(axis=None, dtype=None, out=None, ddof=0, keepdims=False, *, where=True) Returns the variance of the array elements, along given axis. Refer to `numpy.var` for full documentation. See Also -------- numpy.var : equivalent function view(...) a.view([dtype][, type]) New view of array with the same data. .. note:: Passing None for ``dtype`` is different from omitting the parameter, since the former invokes ``dtype(None)`` which is an alias for ``dtype('float_')``. Parameters ---------- dtype : data-type or ndarray sub-class, optional Data-type descriptor of the returned view, e.g., float32 or int16. Omitting it results in the view having the same data-type as `a`. This argument can also be specified as an ndarray sub-class, which then specifies the type of the returned object (this is equivalent to setting the ``type`` parameter). type : Python type, optional Type of the returned view, e.g., ndarray or matrix. Again, omission of the parameter results in type preservation. Notes ----- ``a.view()`` is used two different ways: ``a.view(some_dtype)`` or ``a.view(dtype=some_dtype)`` constructs a view of the array's memory with a different data-type. This can cause a reinterpretation of the bytes of memory. ``a.view(ndarray_subclass)`` or ``a.view(type=ndarray_subclass)`` just returns an instance of `ndarray_subclass` that looks at the same array (same shape, dtype, etc.) This does not cause a reinterpretation of the memory. For ``a.view(some_dtype)``, if ``some_dtype`` has a different number of bytes per entry than the previous dtype (for example, converting a regular array to a structured array), then the behavior of the view cannot be predicted just from the superficial appearance of ``a`` (shown by ``print(a)``). It also depends on exactly how ``a`` is stored in memory. Therefore if ``a`` is C-ordered versus fortran-ordered, versus defined as a slice or transpose, etc., the view may give different results. Examples -------- >>> x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)]) Viewing array data using a different type and dtype: >>> y = x.view(dtype=np.int16, type=np.matrix) >>> y matrix([[513]], dtype=int16) >>> print(type(y)) Creating a view on a structured array so it can be used in calculations >>> x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)]) >>> xv = x.view(dtype=np.int8).reshape(-1,2) >>> xv array([[1, 2], [3, 4]], dtype=int8) >>> xv.mean(0) array([2., 3.]) Making changes to the view changes the underlying array >>> xv[0,1] = 20 >>> x array([(1, 20), (3, 4)], dtype=[('a', 'i1'), ('b', 'i1')]) Using a view to convert an array to a recarray: >>> z = x.view(np.recarray) >>> z.a array([1, 3], dtype=int8) Views share data: >>> x[0] = (9, 10) >>> z[0] (9, 10) Views that change the dtype size (bytes per entry) should normally be avoided on arrays defined by slices, transposes, fortran-ordering, etc.: >>> x = np.array([[1,2,3],[4,5,6]], dtype=np.int16) >>> y = x[:, 0:2] >>> y array([[1, 2], [4, 5]], dtype=int16) >>> y.view(dtype=[('width', np.int16), ('length', np.int16)]) Traceback (most recent call last): ... ValueError: To change to a dtype of a different size, the array must be C-contiguous >>> z = y.copy() >>> z.view(dtype=[('width', np.int16), ('length', np.int16)]) array([[(1, 2)], [(4, 5)]], dtype=[('width', '> x = np.arange(1, 7).reshape(2, 3) >>> x array([[1, 2, 3], [4, 5, 6]]) >>> x.flat[3] 4 >>> x.T array([[1, 4], [2, 5], [3, 6]]) >>> x.T.flat[3] 5 >>> type(x.flat) An assignment example: >>> x.flat = 3; x array([[3, 3, 3], [3, 3, 3]]) >>> x.flat[[1,4]] = 1; x array([[3, 1, 3], [3, 1, 3]]) imag The imaginary part of the array. Examples -------- >>> x = np.sqrt([1+0j, 0+1j]) >>> x.imag array([ 0. , 0.70710678]) >>> x.imag.dtype dtype('float64') itemsize Length of one array element in bytes. Examples -------- >>> x = np.array([1,2,3], dtype=np.float64) >>> x.itemsize 8 >>> x = np.array([1,2,3], dtype=np.complex128) >>> x.itemsize 16 nbytes Total bytes consumed by the elements of the array. Notes ----- Does not include memory consumed by non-element attributes of the array object. Examples -------- >>> x = np.zeros((3,5,2), dtype=np.complex128) >>> x.nbytes 480 >>> np.prod(x.shape) * x.itemsize 480 ndim Number of array dimensions. Examples -------- >>> x = np.array([1, 2, 3]) >>> x.ndim 1 >>> y = np.zeros((2, 3, 4)) >>> y.ndim 3 real The real part of the array. Examples -------- >>> x = np.sqrt([1+0j, 0+1j]) >>> x.real array([ 1. , 0.70710678]) >>> x.real.dtype dtype('float64') See Also -------- numpy.real : equivalent function shape Tuple of array dimensions. The shape property is usually used to get the current shape of an array, but may also be used to reshape the array in-place by assigning a tuple of array dimensions to it. As with `numpy.reshape`, one of the new shape dimensions can be -1, in which case its value is inferred from the size of the array and the remaining dimensions. Reshaping an array in-place will fail if a copy is required. Examples -------- >>> x = np.array([1, 2, 3, 4]) >>> x.shape (4,) >>> y = np.zeros((2, 3, 4)) >>> y.shape (2, 3, 4) >>> y.shape = (3, 8) >>> y array([[ 0., 0., 0., 0., 0., 0., 0., 0.], [ 0., 0., 0., 0., 0., 0., 0., 0.], [ 0., 0., 0., 0., 0., 0., 0., 0.]]) >>> y.shape = (3, 6) Traceback (most recent call last): File \"\", line 1, in ValueError: total size of new array must be unchanged >>> np.zeros((4,2))[::2].shape = (-1,) Traceback (most recent call last): File \"\", line 1, in AttributeError: Incompatible shape for in-place modification. Use `.reshape()` to make a copy with the desired shape. See Also -------- numpy.reshape : similar function ndarray.reshape : similar method size Number of elements in the array. Equal to ``np.prod(a.shape)``, i.e., the product of the array's dimensions. Notes ----- `a.size` returns a standard arbitrary precision Python integer. This may not be the case with other methods of obtaining the same value (like the suggested ``np.prod(a.shape)``, which returns an instance of ``np.int_``), and may be relevant if the value is used further in calculations that may overflow a fixed size integer type. Examples -------- >>> x = np.zeros((3, 5, 2), dtype=np.complex128) >>> x.size 30 >>> np.prod(x.shape) 30 strides Tuple of bytes to step in each dimension when traversing an array. The byte offset of element ``(i[0], i[1], ..., i[n])`` in an array `a` is:: offset = sum(np.array(i) * a.strides) A more detailed explanation of strides can be found in the \"ndarray.rst\" file in the NumPy reference guide. Notes ----- Imagine an array of 32-bit integers (each 4 bytes):: x = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]], dtype=np.int32) This array is stored in memory as 40 bytes, one after the other (known as a contiguous block of memory). The strides of an array tell us how many bytes we have to skip in memory to move to the next position along a certain axis. For example, we have to skip 4 bytes (1 value) to move to the next column, but 20 bytes (5 values) to get to the same position in the next row. As such, the strides for the array `x` will be ``(20, 4)``. See Also -------- numpy.lib.stride_tricks.as_strided Examples -------- >>> y = np.reshape(np.arange(2*3*4), (2,3,4)) >>> y array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]]) >>> y.strides (48, 16, 4) >>> y[1,1,1] 17 >>> offset=sum(y.strides * np.array((1,1,1))) >>> offset/y.itemsize 17 >>> x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0) >>> x.strides (32, 4, 224, 1344) >>> i = np.array([3,5,2,2]) >>> offset = sum(i * x.strides) >>> x[3,5,2,2] 813 >>> offset / x.itemsize 813 ---------------------------------------------------------------------- Data and other attributes defined here: \\_\\_hash__ = None "},{"title":"python pandas","date":"2022-04-30T01:47:08.197Z","url":"/2022/04/30/pandas/","tags":[["programming,Python,pandas","/tags/programming-Python-pandas/"]],"categories":[[" ",""]],"content":"pandas先載入 pandas包含了numpy和matplotlib的部分功能，要用到的時候不用額外import pandas主要包含兩種資料型別 Series 和 DataFrameSeriesSeries像是能自訂索引的numpy陣列建立： “數據”可以是list/tuple/可迭代物件/numpy陣列，內容只能是數字默認索引是從零開始，就和一般的陣列一樣也可以自訂索引： “索引”可以是list/tuple/可迭代物件/numpy陣列，內容可以是任何內容，可以重複可以使用像是numpy的方式取出資料，若取出不只一筆資料則輸出Series就和一般的陣列一樣注意如果有用自訂索引就不一定能用數字索引也可以像numpy的方式直接四則運算，但計算結果仍然是Series Series有一個特別的運算可以逐個進行in計算 isin輸出一個Series[bool]表示每個元素是否在物件中常用於DataFrame的索引單獨取出索引&#x2F;資料： DataFrameDataFrame是pandas的核心功能所在結構類似表格或試算表包含多個有序的欄位每個欄位是固定資料型態，不同欄位可以是不同資料型態每個欄位都是一個Series可以用默認索引，也可以用自訂索引Ex: 用Jupyter顯示： 匯入與匯出DataFrame可以直接由檔案匯入&#x2F;匯出至檔案支援.csv .json .html .xlsx格式注意：要支援.xlsx格式需要額外安裝openpyxl(不需要import)直接pip install openpyxl就可以了語法： 取出&#x2F;顯示資料前&#x2F;後幾筆資料用head&#x2F;tail可以取出前&#x2F;後幾筆資料輸出依然是DataFrame格式 內部資料 摘要 索引DataFrame類似於二維列表，第一維是欄位標籤可用寫法 若要使用類似numpy的雙索引系統，可使用： 在此處第一維是欄位標籤，且索引要用欄位標籤和自訂索引名稱若要用數字索引，可用： 排序 照(單/多個)欄位標籤決定排序優先程度ascending=True為遞增排序回傳排序過的DataFrame，不更改原來的 資料增刪利用索引可以進行資料讀取&#x2F;編輯寫入不存在的索引可以進行資料新增資料刪除則使用drop axis決定是要刪掉一些資料還是刪掉一些欄位axis=0(默認)表示刪掉一些資料axis=1(默認)表示刪掉一些欄位 資料視覺化pandas有整合matplotlib的繪製圖表功能但如果要用中文還是需要在繪圖的程式碼以前寫下 繪圖語法： 如果用的是Jupyter會在執行完此行後顯示(只能放在Cell的結尾)其他情況可用 來強制顯示可用的類型包含： 名稱 中文名稱 line 折線圖 bar 長條圖 barh 橫長條圖 box 箱形圖 hist 直方圖 kde 核密度估計圖 area 塗色折線圖 pie 圓餅圖 scatter 散佈圖 hexbin 六邊形分箱圖 部分類型需要額外參數 圓餅圖需要y=&quot;欄位名稱&quot;來定義要畫圖的欄位 或使用subplots=True表達每一個欄位都畫一個圖 散佈圖、六邊形分箱圖需要x=&quot;欄位名稱&quot;,y=&quot;欄位名稱&quot;來定義x,y軸 "},{"title":"Python基礎語法","date":"2022-04-30T01:46:47.760Z","url":"/2022/04/30/basic/","tags":[["programming,Python","/tags/programming-Python/"]],"categories":[[" ",""]],"content":"基礎語法換行在Python裡每換一行就代表下一段程式碼，不需要也不能有分號但在以下兩個情況電腦會將不同行看成同一段程式碼 括號未完成 可以寫成 行結尾是反斜槓 可以寫成 這兩種寫法一般用在一行程式碼太長的時候，換行寫比較好看 註解有時候在程式中需要注明一些程式的功能，就可以用註解單行註解用一個井字號開頭： 多行註解用三個引號包起來： 變數變數是給資料值的一個”暱稱”，可以告訴電腦該資料值之後可能會用到，不要刪掉。 賦值賦值即是把一個”暱稱”設定給一個資料值 或著 注： 這種寫法在資料值可變時會使兩個變數代表同個值，使其連動 可以用這樣的寫法來做淺複製(詳細的\"變數與型別\"再說) 範例： 變數名稱可以是任何的文字，可以用任何語言，但通常建議用英文且不能和保留字重複也建議不要和內建的函數、常數、類型重名(可能會有非預期的結果)不能以數字開頭(可以包含數字)，不能包含計算符號(加減乘除之類的符號) 保留字 False、None、True、and、as、assert、async、await、break、class、continue、def、del、elif、else、except、finally、for、from、global、if、import、in、is、lambda、nonlocal、not、or、pass、raise、return、try、while、with、yield 內建函數、常數、類型名稱 ArithmeticError、AssertionError、AttributeError、BaseException、BlockingIOError、BrokenPipeError、BufferError、BytesWarning、ChildProcessError、ConnectionAbortedError、ConnectionError、ConnectionRefusedError、ConnectionResetError、DeprecationWarning、EOFError、Ellipsis、EncodingWarning、EnvironmentError、Exception、False、FileExistsError、FileNotFoundError、FloatingPointError、FutureWarning、GeneratorExit、IOError、ImportError、ImportWarning、IndentationError、IndexError、InterruptedError、IsADirectoryError、KeyError、KeyboardInterrupt、LookupError、MemoryError、ModuleNotFoundError、NameError 、None、NotADirectoryError、NotImplemented、NotImplementedError、OSError、OverflowError、PendingDeprecationWarning、PermissionError、ProcessLookupError、RecursionError、ReferenceError、ResourceWarning、RuntimeError、RuntimeWarning、StopAsyncIteration、StopIteration、SyntaxError、SyntaxWarning、SystemError、SystemExit、TabError、TimeoutError、True、TypeError 、UnboundLocalError、UnicodeDecodeError、UnicodeEncodeError、UnicodeError、UnicodeTranslateError、UnicodeWarning、UserWarning、ValueError、Warning、WindowsError、ZeroDivisionError、\\_\\_build\\_class\\_\\_、\\_\\_debug\\_\\_、\\_\\_doc\\_\\_、\\_\\_import\\_\\_、\\_\\_loader\\_\\_、\\_\\_name\\_\\_、\\_\\_package\\_\\_、\\_\\_spec\\_\\_、abs、aiter、all、anext、any、ascii、bin、bool、breakpoint、bytearray、bytes、callable、chr、classmethod、compile、complex、copyright、credits、delattr、dict、dir、divmod、enumerate、eval、exec、exit、filter、float、format、frozenset、getattr、globals、hasattr、hash、help、hex、id、input、int、isinstance、issubclass、iter、len、license、list、locals、map、max、memoryview、min、next、object、oct、open、ord、pow、print、property、quit、range、repr、reversed、round、set、setattr、slice、sorted、staticmethod、str、sum、super、tuple、type、vars、zip 辨別方法： 通常編輯器在碰到以上名稱時，都會有特殊顏色，若有出現則盡量避免使用該名稱，或是在結尾加一個底線 使用變數名稱可以直接當作一個資料值來處理 常用資料類型在程式中，所有的資料值都有類型，用來讓電腦分辨要如何處裡資料可以用 來獲取資料值的類型 常用資料類型包括： 布林值 bool 整數 int 浮點數 float 複數 complex 字串 str 空值 NoneType 還有一些類型是用來儲存多個資料的，包括： 元組 tuple 清單 list (可變) 集合 set (可變) 不可變集合 frozenset 字典 dict (可變) 布林值布林值是表示”是”和”否”的資料“是”寫作 “否”寫作 大小寫必須正確布林值可以和數字混在一起計算True&#x3D;1, False&#x3D;0 數字數字就是數字比較需要注意的是虛數符號要用”j”而非”i”且”1j”不能簡記為”j”範例： 字串字串表示一段文字在程式中要用英文引號包起來範例： 空值空值用於標記不存在&#x2F;未確定的值表示為： 元組元組表示並列且有序的一組任意長度的資料值長度不可改變，元素不可寫入範例： 可用方法詳細介紹： count(value): Return number of occurrences of value. *** index(value, start=0, stop=9223372036854775807): Return first index of value. Raises ValueError if the value is not present. 清單清單表示並列且有序的一組任意長度的資料值可插入&#x2F;刪除資料類似C++的vector範例： 可用方法詳細介紹： append(object): Append object to the end of the list. *** clear(): Remove all items from list. *** copy(): Return a shallow copy of the list. *** count(value): Return number of occurrences of value. *** extend(iterable): Extend list by appending elements from the iterable. *** index(value, start=0, stop=9223372036854775807): Return first index of value. Raises ValueError if the value is not present. *** insert(index, object): Insert object before index. *** pop(index=-1): Remove and return item at index (default last). Raises IndexError if list is empty or index is out of range. *** remove(value): Remove first occurrence of value. Raises ValueError if the value is not present. *** reverse(): Reverse \\*IN PLACE\\*. *** sort(key=None, reverse=False): Sort the list in ascending order and return None. The sort is in-place (i.e. the list itself is modified) and stable (i.e. the order of two equal elements is maintained). If a key function is given, apply it once to each list item and sort them, ascending or descending, according to their function values. The reverse flag can be set to sort in descending order. 集合清單表示無序不重複的一組任意長度的資料值並能夠在常數時間裡檢查一元素是否在集合中類似數學上的集合類似C++的unordered_set不能存可變的值，如：list、set、dict要存其他set必須轉換成frozenset範例： 可用方法詳細介紹： add(): Add an element to a set. This has no effect if the element is already present. *** clear(): Remove all elements from this set. *** copy(): Return a shallow copy of a set. *** difference(): Return the difference of two or more sets as a new set. (i.e. all elements that are in this set but not the others.) *** difference_update(): Remove all elements of another set from this set. *** discard(): Remove an element from a set if it is a member. If the element is not a member, do nothing. *** intersection(): Return the intersection of two sets as a new set. (i.e. all elements that are in both sets.) *** intersection_update(): Update a set with the intersection of itself and another. *** isdisjoint(): Return True if two sets have a null intersection. *** issubset(): Report whether another set contains this set. *** issuperset(): Report whether this set contains another set. *** pop(): Remove and return an arbitrary set element. Raises KeyError if the set is empty. *** remove(): Remove an element from a set; it must be a member. If the element is not a member, raise a KeyError. *** symmetric_difference(): Return the symmetric difference of two sets as a new set. (i.e. all elements that are in exactly one of the sets.) *** symmetric_difference_update(): Update a set with the symmetric difference of itself and another. *** union(): Return the union of sets as a new set. (i.e. all elements that are in either set.) *** update(): Update a set with the union of itself and others. 字典字典是鍵-值對的資料結構鍵是唯一的，值不一定唯一在較新的python版本(3.7+)中鍵會按照加入的順序排列類似C++的unordered_map 可用方法詳細介紹： clear(): D.clear() -> None. Remove all items from D. *** copy(): D.copy() -> a shallow copy of D *** fromkeys(iterable, value=None): Create a new dictionary with keys from iterable and values set to value. *** get(key, default=None): Return the value for key if key is in the dictionary, else default. *** items(): D.items() -> a set-like object providing a view on D's items *** keys(): D.keys() -> a set-like object providing a view on D's keys *** pop(): D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If the key is not found, return the default if given; otherwise, raise a KeyError. *** popitem(): Remove and return a (key, value) pair as a 2-tuple. Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty. *** setdefault(key, default=None): Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default. *** update(): D.update([E, ]\\*\\*F) -> None. Update D from dict/iterable E and F. If E is present and has a .keys() method, then does: for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v In either case, this is followed by: for k in F: D[k] = F[k] *** values(): D.values() -> an object providing a view on D's values 順帶一提類型名稱可以視為一個函數，用來複製資料值或把其他類型的資料轉換成當前類型較常用的有int(),float(),str(),bool(),list()範例： 輸出和輸入輸出 把數值列印到螢幕上，並換行不想要結尾換行可以這樣寫： 輸入 先輸出一行字(不換行)(可選)，再接收一行字串 基礎計算符常用的計算符包含： 數學計算符 + - * / // % ** 比較計算符 &gt; &lt; &gt;= &lt;= == != 位元計算符 &lt;&lt; | &amp; ^ &gt;&gt; ~ 邏輯計算符 not or and 賦值計算符 += -= *= /= //= %= **= &lt;&lt;= &gt;&gt;= |= &amp;= ^= 其他 [] () &#123;&#125; is is not in not in 總表： 順序 方向 形式 名稱 1 右至左 a**b 指數 2 左至右 ~a 按位反轉 2 左至右 +a 正號 2 左至右 -a 負號 3 左至右 a*b 乘法 3 左至右 a&#x2F;b 除法 3 左至右 a&#x2F;&#x2F;b 整除法 3 左至右 a%b 取餘數 4 左至右 a+b 加法 4 左至右 a-b 減法 5 左至右 a&lt;&lt;b 位元左移 5 左至右 a&gt;&gt;b 位元右移 6 左至右 a&amp;b 按位且 7 左至右 a^b 按位異或 7 左至右 a|b 按位或 8 左至右 a&#x3D;&#x3D;b 相等 8 左至右 a&lt;&#x3D;b 小於等於 8 左至右 a&gt;&#x3D;b 大於等於 8 左至右 a&lt;b 小於 8 左至右 a&gt;b 大於 8 左至右 a!&#x3D;b 不相等 8 左至右 a is b 相同 8 左至右 a is not b 不相同 8 左至右 a in b a在b之中 8 左至右 a not in b a不在b之中 9 左至右 not a 邏輯非 10 左至右 a and b 邏輯且 11 左至右 a or b 邏輯或 12 左至右 a &#x3D; b 賦值計算符 條件判斷條件判斷可以指定在特定條件符合值才執行部分程式碼 迴圈for迴圈：for迴圈可以對可迭代物件中的每一項進行相同的處理 需要注意的是，直接對字典進行迭代與對鍵值進行迭代效果相同可迭代物件中 有兩個常用在for迴圈裡 range enumerate rangerange有三種寫法 range代表一個從開頭到結尾間隔步長的等差數列(不包含結尾)開頭默認為0，步長默認為1三個值都可以是負的range不會直接產生數列，而是在要用到的時候才計算 enumerateenumerate語法如下 enumerate輸入一個可迭代物件，輸出的每一元素為(編號,值)的元組通常寫作 while迴圈：while迴圈可以在條件符合時不斷重複相同程式碼 自訂函數自訂函數可以把重複用到的功能打包起來，方便使用語法： 三元運算子三元運算子可以簡化條件判斷語法： 空格不能省略這一整個可以視為一個值當條件成立，輸出值1；當條件不成立，輸出值2Ex: 可簡化為 推導式(Comprehension)這沒有統一的翻譯，在此暫時稱之為推導式推導式來源於數學中的集合建構式如下：$$集合&#x3D;{輸出表達式|變量\\in輸入集合, 謂詞}$$Python中的推導式有4種，分別是 列表推導式(List Comprehension) 集合推導式(Set Comprehension) 字典推導式(Dictionary Comprehension) 生成器表達式(Generator Expression)共通語法： 列表推導式(List Comprehension)算是其中較常用的一種元素的順序會被保留使用中括號[] 集合推導式(Set Comprehension)與列表推導式類似，會去除相同的元素元素的順序會不被保留使用大括號{} 字典推導式(Dictionary Comprehension)與集合推導式類似，會覆蓋鍵值相同的元素輸出表達式必須為 鍵值:值 的格式元素的順序會被保留使用大括號{} 生成器表達式(Generator Expression)雖然名稱不同但用法類似但它並不會在表達式完成前求出所有元素的值而是產生一個生成器，用到的時候再求出元素的值若各元素只會被用到一次，相較於列表推導式可節省記憶體與時間元素的順序會被保留使用小括號()"},{"title":"python scipy","date":"2022-04-30T01:46:38.579Z","url":"/2022/04/30/scipy/","tags":[["programming,Python,scipy","/tags/programming-Python-scipy/"]],"categories":[[" ",""]],"content":"scipy特殊函數 special所有特殊函數都可以接受列表&#x2F;陣列為輸入值，但若輸入多個值輸出必為numpy陣列 指數 三角函數(使用角度) 微積分 integrate定積分 area 計算結果 err 絕對誤差估計值 func 要做定積分的函數可以在參數列結尾加一個tuple做為傳給func的額外參數 low 定積分下界 up 定積分上界若需要無限大必須使用numpy.inf 線性代數 linalg反矩陣 行列式 線性方程求解$Ax &#x3D; b$ 最佳化 optimize最小值 func 要做定積分的函數可以在參數列結尾加一個tuple做為傳給func的額外參數 x0 搜尋起始點 result 回傳結果，是它自己獨有的資料型別，常用屬性如下 屬性名 意義 x 一個陣列，表示找到的最小值位置(可能有多個) func 最小值的值 success 有沒有找到 內插 interpolate 統計 stats常態分佈 敘述統計 result 回傳結果，是它自己獨有的資料型別，常用屬性如下屬性名|意義 minmax|一個元組，表示最大與最小值 mean|平均值 訊號處理 signal卷積 img 目標圖片 core 卷積核 mode 模式，建議用”same” boundary 邊界處裡，建議用”symm” "},{"title":"小橘子的編程筆記-Python篇","date":"2022-04-30T01:42:51.603Z","url":"/2022/04/30/pythonnote/","tags":[["programming,Python","/tags/programming-Python/"]],"categories":[[" ",""]],"content":"小橘子的編程筆記-Python篇語法 基礎語法 變數與型別 談談builtins 函數 自訂型別 檔案輸出入 函數庫 談談package 常用 檔案處裡：os 系統操作：sys JSON：json 時間：time 隨機：ramdom 數學 基礎數學計算：math 矩陣運算：numpy 資料視覺化：matplotlib 資料整理：pandas 進階數學計算：scipy 機器學習 基礎：sklearn 框架：keras 核心：tensorflow GUI 遊戲：pygame 排版：pyqt5 排版：tkinter 網路"}]